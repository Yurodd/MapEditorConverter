import "customGameSettings.lobby";
globalvar define AllPos = EmptyArray();
globalvar define AllDir = EmptyArray();
playervar define filterpos = EmptyArray();
globalvar define firstpos = EmptyArray();
globalvar define secondpos = EmptyArray();
globalvar define firstpoint2 = EmptyArray();
globalvar define secondpoint2 = EmptyArray();
globalvar define second;
playervar define point;
globalvar define z;
globalvar define destroyall = false;
playervar define lastsavedpos = 0;
playervar define closestbodypos =0;
playervar define fullbodypos =0;
globalvar define beam_ID = EmptyArray();
playervar define horizontal_points = EmptyArray();
playervar define vertical_points = EmptyArray();
playervar define horizontal_effect_id = EmptyArray();
playervar define beamType = 1;
globalvar define g_beamType = EmptyArray();
//globalvar define sphereRadius = EmptyArray();
//globalvar define spherePos = EmptyArray();

//////////////////UI Variables//////////////
globalvar define showwalls = true;
playervar define openui = false;
playervar define UIVector;
playervar define UI_ID=0; //0 =  No Wall Default
globalvar define Wall_ID;
playervar define UI_SelectWall;
playervar define Selected_Wall;
playervar define Selected_Wall_Click;
playervar define Selected_Wall_Effect_ID ;
playervar define closestSelection;
playervar define prevpos_intersection=0;
playervar define active_wall=0;
playervar define AllVertices;
playervar define closestvertices;
playervar define closest_beam_intersection;
playervar define cursor_snap_Tool = 1;
playervar define page=1;
playervar define flymode = false;
playervar define UI_FacingDir;
playervar define radius = 0.1;
playervar define closestwall;
playervar define confirmcount;

playervar define closest_firstpos;
playervar  define closest_secondpos ;
playervar  define closest_firstpoint2 ;
playervar  define closest_secondpoint2 ;
playervar define saved_pos! = PositionOf();

playervar define beam_dir = EmptyArray();
playervar define beam_Cursor_ID;
playervar define all_beam_intersection = EmptyArray();
playervar define arcballMode;
playervar define lastmousepos;
playervar define is_Grounded;
playervar define start_mirror;
playervar define temp_Selected_Wall;
globalvar define sphereRadius;
playervar define measureTextEntity = EmptyArray();
playervar define teleport_temp_point;
globalvar define teleportPos;
globalvar define teleportDirection;
globalvar define teleport_effect_ID;
globalvar define teleport_beameffect_ID;
globalvar define strafeToggle = WorkshopSettingToggle("CSGO Movement","Air Strafe",false,0);
playervar define prev_throttledir;
playervar define prev_facingdir;
playervar define teleporting;
playervar define currentspeed;
playervar define addspeed;
playervar define accel_speed = 1;
playervar define max_horizontal_speed = 5.5;
playervar define current_Slope_Dir;
playervar define inEraser;

////////////////////////////////////////



rule:"Movement"
Event.OngoingPlayer
if(strafeToggle && !flymode)
{
     prev_throttledir = Normalize(WorldVectorOf(ThrottleOf(EventPlayer()), EventPlayer(), LocalVector.Rotation));
     prev_facingdir = FacingDirectionOf();
     Wait(0.016);
     if(is_Grounded == false && IsOnGround() == false && teleporting == false)
    {
        if(SpeedOfInDirection(eventPlayer,Normalize(WorldVectorOf(Vector(0,0,1),eventPlayer))) > 1)
        {

        if (ZOf(ThrottleOf(EventPlayer())) <= 0.5 && XOf(ThrottleOf(EventPlayer())) != 0 && DotProduct(prev_throttledir * Vector(1,0,1), FacingDirectionOf() * Vector(1, 0, 1)) > 0)
        {
            // currentspeed = DotProduct(VelocityOf(EventPlayer()), Normalize(Normalize(WorldVectorOf(ThrottleOf(EventPlayer()), EventPlayer(), LocalVector.Rotation)) + FacingDirectionOf(EventPlayer()) * Vector(1, [], 1)));
             currentspeed = DotProduct(VelocityOf(EventPlayer())* Vector(1,0,1), prev_throttledir * Vector(1,0,1));
            addspeed = accel_speed - currentspeed;
            addspeed = Max(Min(addspeed, accel_speed* 0.016), 0);
            max_horizontal_speed = max_horizontal_speed + addspeed ;
            ApplyImpulse(EventPlayer(), FacingDirectionOf() * Vector(1,0,1), max_horizontal_speed, Relative.ToWorld, ContraryMotion.Cancel);
            ApplyImpulse(EventPlayer(), CrossProduct(Vector(0,XOf(ThrottleOf()),0), FacingDirectionOf() * Vector(1,0,1)), 0.001, Relative.ToWorld, ContraryMotion.Cancel);
        }
        else if((ThrottleOf(EventPlayer()) == Vector(0, 0, 0) || ZOf(ThrottleOf(EventPlayer())) > 0.5) )
        {
            currentspeed = DotProduct(VelocityOf(EventPlayer())* Vector(1,0,1), prev_throttledir * Vector(1,0,1));
            addspeed = accel_speed - currentspeed;
            addspeed = Max(Min(addspeed, accel_speed* 0.016), 0);
            max_horizontal_speed = Max(max_horizontal_speed - accel_speed* 0.016,5.5);
            ApplyImpulse(EventPlayer(),Normalize(VelocityOf()) * Vector(1,0,1),max_horizontal_speed);
        }
        else if(XOf(ThrottleOf(EventPlayer())) != 0 && DotProduct(prev_throttledir * Vector(1,0,1), FacingDirectionOf() * Vector(1, 0, 1)) < 0 )
        {
            currentspeed = DotProduct(VelocityOf(EventPlayer())* Vector(1,0,1), prev_throttledir * Vector(1,0,1));
            addspeed = accel_speed - currentspeed;
            addspeed = Max(Min(addspeed, accel_speed* 0.016), 0);
            max_horizontal_speed = Max(max_horizontal_speed - accel_speed* 0.016,5.5);
            ApplyImpulse(EventPlayer(),(VelocityOf() + (Normalize(WorldVectorOf(ThrottleOf(EventPlayer()), EventPlayer())) + FacingDirectionOf())) * Vector(1,0,1) ,max_horizontal_speed);
        }
        else if(XOf(ThrottleOf(EventPlayer())) != 0 && DotProduct(prev_throttledir * Vector(1,0,1), FacingDirectionOf() * Vector(1, 0, 1)) == 0 &&
                DotProduct(current_Slope_Dir * Vector(1,0,1),Normalize(WorldVectorOf(ThrottleOf(EventPlayer()), EventPlayer()))* Vector(1,0,1)) < 0)
        {
             ApplyImpulse(EventPlayer(),FacingDirectionOf() * Vector(1,0,1) ,max_horizontal_speed);
            ApplyImpulse(EventPlayer(), CrossProduct(Vector(0,XOf(ThrottleOf()),0), FacingDirectionOf() * Vector(1,0,1)), 0.001, Relative.ToWorld, ContraryMotion.Cancel);

        }

        else{
             ApplyImpulse(EventPlayer(), Normalize(VelocityOf()) * Vector(1,0,1), max_horizontal_speed, Relative.ToWorld, ContraryMotion.Cancel);

        }


            if(DistanceBetween(RayCastHitPosition(EyePosition(),EyePosition() + Down() * 100),PositionOf()) < 0.3 && IsButtonHeld(eventPlayer,Button.Jump)
            && IsTrueForAll(inEraser,ArrayElement() == false))
            {
                //ApplyImpulse(eventPlayer, Up(), 17.5 * 0.016  ,Relative.ToWorld,ContraryMotion.Incorporate)
                ApplyImpulse(eventPlayer,Up(),5);
                // if(HorizontalSpeedOf()>0)
                // {
                // ApplyImpulse(eventPlayer,FacingDirectionOf() * Vector(1,0,1),HorizontalSpeedOf());
                // //SmallMessage(eventPlayer,"hoppiny");
                // }
            }

            if(DistanceBetween(RayCastHitPosition(EyePosition(),EyePosition() + (VelocityOf() * 0.016) ), EyePosition()) < (SpeedOf() * 0.016) &&
            IsTrueForAll(inEraser,ArrayElement() == false) && !IsInLineOfSight(EyePosition(),EyePosition() + (VelocityOf() * 0.016)))
            {
                ApplyImpulse(eventPlayer,RayCastHitNormal(EyePosition(),EyePosition() + (VelocityOf() * 0.016)),2);
                max_horizontal_speed = 5.5;
                //SmallMessage(eventPlayer,"Collision with environment detected");
            }
        }
    }
    else
    {
    max_horizontal_speed = SpeedOf();
    StopAccelerating(EventPlayer());
    }
 LoopIfConditionIsTrue();
}

rule: "Main Collision Logic"
Event.OngoingPlayer
if (HasSpawned())
{

    lastsavedpos = Midpoint(EyePosition(),PositionOf());

    MinWait();

    if(!flymode)
        {
            //  closestwall = FilteredArray(AllPos,active_wall[CurrentArrayIndex()] == 1 ||
            // DistanceBetween(eventPlayer + AllDir[CurrentArrayIndex()] * DotProduct(ArrayElement() - eventPlayer,AllDir[CurrentArrayIndex()]) / DotProduct(AllDir[CurrentArrayIndex()], AllDir[CurrentArrayIndex()]),eventPlayer) < 2
            // || (DotProduct(DirectionTowards(ArrayElement(),lastsavedpos),AllDir[CurrentArrayIndex()]) > 0) != (DotProduct(DirectionTowards(ArrayElement(),eventPlayer),AllDir[CurrentArrayIndex()]) > 0)
            // || Wall_ID[CurrentArrayIndex()] == 6 || Wall_ID[CurrentArrayIndex()] == 9);

             closestwall = FilteredArray(AllPos,
             DistanceBetween(AllPos[CurrentArrayIndex()],eventPlayer) <= DistanceBetween(AllPos[CurrentArrayIndex()],firstpos[CurrentArrayIndex()])
             || active_wall[CurrentArrayIndex()] == 1 || (DotProduct(DirectionTowards(ArrayElement(),lastsavedpos),AllDir[CurrentArrayIndex()]) > 0) != (DotProduct(DirectionTowards(ArrayElement(),eventPlayer),AllDir[CurrentArrayIndex()]) > 0)
             );

            for( define x =0; CountOf(closestwall);1)
            {
                z = IndexOfArrayValue(AllPos,closestwall[x]);
                if(Wall_ID[z] == 1 || Wall_ID[z] == 3|| Wall_ID[z] == 5) //all vertical walls. 1 vertical, 3 bouncy, 5 vertical eraser
                {
                if(YOf(firstpos[z]) >= YOf(PositionOf()) && YOf(firstpos[z]) <= YOf(EyePosition()+Vector(0,0.2,0)))
                {
                    closestbodypos = firstpos[z];
                }
                else if(YOf(secondpos[z]) >= YOf(PositionOf()) && YOf(secondpos[z]) <= YOf(EyePosition()+Vector(0,0.2,0)))
                {
                    closestbodypos = secondpos[z];
                }
                else
                {
                    closestbodypos = PositionOf();
                }

                //closestbodypos = FirstOf(SortedArray(allbodypos,DistanceBetween(ArrayElement(),AllPos[z])));
                fullbodypos = Vector(XOf(EyePosition()),YOf(closestbodypos),ZOf(EyePosition()));
                filterpos = fullbodypos + AllDir[z] * DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(AllDir[z], AllDir[z]);

                if(Wall_ID[z] == 1 || Wall_ID[z] == 3)
                    {

                        if((DotProduct(DirectionTowards(AllPos[z],lastsavedpos),AllDir[z]) > 0) != (DotProduct(DirectionTowards(AllPos[z],fullbodypos),AllDir[z]) > 0))
                        {
                            define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(DirectionTowards(lastsavedpos,fullbodypos) , AllDir[z]);
                                prevpos_intersection = fullbodypos + (DirectionTowards(lastsavedpos,fullbodypos)) * intersection_length;
                            if(fttr_prev_pos >= 0 && ftbl_prev_pos >= 0 && sttr_prev_pos >= 0 && stbl_prev_pos >= 0)
                            {
                            //Teleport(eventPlayer, lastsavedpos + DirectionTowards(fullbodypos,lastsavedpos)*Vector(1,0,1) * (DistanceBetween(lastsavedpos,prevpos_intersection) - 2));
                            CancelPrimaryAction();
                            define temp_calc_pos = prevpos_intersection + DirectionTowards(prevpos_intersection,lastsavedpos) * Vector(1,0,1) * 2;
                            // if(DistanceBetween(RayCastHitPosition(temp_calc_pos,temp_calc_pos + Down() * 100),temp_calc_pos + Down() * 100) == 0)
                            // Teleport(eventPlayer,lastsavedpos);
                            // else
                            Teleport(eventPlayer,temp_calc_pos);
                            // if(HeroOf() != Hero.Tracer)
                            // Teleport(eventPlayer,RayCastHitPosition(lastsavedpos,lastsavedpos + DirectionTowards(lastsavedpos,prevpos_intersection) * (DistanceBetween(lastsavedpos,prevpos_intersection) - 2)));
                            // else
                            // Teleport(eventPlayer,prevpos_intersection + DirectionTowards(prevpos_intersection,lastsavedpos) * Vector(1,0,1) * 2);
                            }
                        }
                    }


                    define thickness;
                    if(Wall_ID[z] ==5)
                    thickness = 4;
                    else
                    thickness = 1;
                    if(DistanceBetween(fullbodypos,filterpos)<=thickness&&fttr >= 0 && ftbl >= 0 && sttr >= 0 && stbl >= 0)
                    {
                        if(!is_Grounded)
                        {
                         SetGravity(eventPlayer,100);
                        }
                            if(active_wall[z] == false)
                                    {
                                        active_wall[z] = 1;

                                        // if((Wall_ID[z] == 1 || Wall_ID[z] == 3) && is_Grounded == false)
                                        // SetGravity(eventPlayer,100);
                                         if(Wall_ID[z] == 5)
                                        DisableMovementCollisionWithEnvironment();

                                    }

                            if(Wall_ID[z] == 1)
                            {

                                // if(DistanceBetween(fullbodypos,filterpos)<=0.8)
                                // {
                                // //Teleport(eventPlayer,PositionOf() + DirectionTowards(Vector(XOf(filterpos),YOf(PositionOf()),ZOf(filterpos)),PositionOf()) * (1.00000001-1  * DistanceBetween(PositionOf(),Vector(XOf(filterpos),YOf(PositionOf()),ZOf(filterpos)))));
                                // //ApplyImpulse(eventPlayer, DirectionTowards(filterpos,fullbodypos + Normalize(WorldVectorOf(-ThrottleOf(),eventPlayer)) * 5) * Vector(1,0,1), 0.001);
                                // define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)) , AllDir[z]);
                                // prevpos_intersection = fullbodypos + (Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))* Vector(1,0,1)) * intersection_length;
                                // ApplyImpulse(eventPlayer, DirectionTowards(prevpos_intersection,lastsavedpos)* Vector(1,0,1) , 0.001);
                                // }
                                //bookmark
                                //StartThrottleInDirection(eventPlayer,null,false,Relative.ToWorld,ThrottleBehavior.AddToExistingThrottle,ThrottleRev.None);
                                ApplyImpulse(eventPlayer, DirectionTowards(filterpos,fullbodypos) * Vector(1,0,1), 0.001);
                                 if(ThrottleOf()!= Vector())
                                SetMoveSpeed(eventPlayer,100 - (DotProduct(DirectionTowards(EyePosition(),EyePosition() + WorldVectorOf(ThrottleOf(),eventPlayer)),-1*DirectionTowards(filterpos,fullbodypos)) * 100));
                               // StartThrottleInDirection(eventPlayer,null,false,Relative.ToWorld,ThrottleBehavior.AddToExistingThrottle,ThrottleRev.None);

                            }
                            else if(Wall_ID[z] == 3)
                            {
                            ApplyImpulse(eventPlayer, DirectionTowards(filterpos,fullbodypos) , SpeedOf());
                            }

                            if(strafeToggle)
                            {
                                 if(Wall_ID[z] == 5)
                                {
                                    inEraser[z] = true;
                                }
                            }

                        //ApplyImpulse(eventPlayer, DirectionTowards(filterpos,EyePosition()) * Vector(1,0,1),SpeedOf() * 0.001);
                    }
                    else
                    {
                        active_wall[z] = 0;
                        SetMoveSpeed(eventPlayer,100);
                        inEraser[z] = false;
                        //lastsavedpos = PositionOf();
                    }

                }
                 else if(Wall_ID[z] == 2 || Wall_ID[z] == 6 || Wall_ID[z] == 7) // 2 = horizontal, 6 = horizontal erasor 7 = slidey horizontal
                {

                    if(YOf(firstpos[z]) >= YOf(PositionOf()) && YOf(firstpos[z]) <= YOf(EyePosition()+Vector(0,0.2,0)))
                    {
                        closestbodypos = firstpos[z];
                    }
                    else if(YOf(firstpos[z]) <= YOf(PositionOf()))
                    {
                        closestbodypos = PositionOf();
                    }
                    else if(YOf(firstpos[z]) >= YOf(EyePosition()))
                    {
                        closestbodypos = EyePosition();
                    }

                    fullbodypos = Vector(XOf(EyePosition()),YOf(closestbodypos),ZOf(EyePosition()));
                    filterpos = fullbodypos + AllDir[z] * DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(AllDir[z], AllDir[z]);

                    if(Wall_ID[z] == 2 || Wall_ID[z] == 7)
                    {

                        if((DotProduct(DirectionTowards(AllPos[z],lastsavedpos),AllDir[z]) > 0) != (DotProduct(DirectionTowards(AllPos[z],fullbodypos),AllDir[z]) > 0))
                        {
                           define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(DirectionTowards(lastsavedpos,fullbodypos) , AllDir[z]);
                                prevpos_intersection = fullbodypos + (DirectionTowards(lastsavedpos,fullbodypos)* Vector(0,1,0)) * intersection_length;
                            if(DotProduct(Down(),DirectionTowards(lastsavedpos,prevpos_intersection))>0)
                            {
                                if(fttr2_prev_pos >= 0 && ftbl2_prev_pos >= 0 && sttr2_prev_pos >= 0 && stbl2_prev_pos >= 0)
                                {
                                CancelPrimaryAction();
                                //Teleport(eventPlayer,prevpos_intersection + DirectionTowards(prevpos_intersection,lastsavedpos) * Vector(0,1,0) * 1);


                                        if(HeroOf(eventPlayer) == Hero.WreckingBall)
                                        {
                                        Teleport(eventPlayer, NearestWalkablePosition(prevpos_intersection));
                                        Wait(0.016);
                                        Teleport(eventPlayer, prevpos_intersection + Up() * 1);
                                        }
                                        else
                                        Teleport(eventPlayer,prevpos_intersection + Up() * 1);

                                }
                            }

                        }

                    }
                        define thickness;
                        if(Wall_ID[z] ==6)
                        thickness = 6;
                        else
                        thickness = 0.5;

                    if(DistanceBetween(filterpos,fullbodypos)<=thickness && fttr2 >= 0 && ftbl2 >= 0 && sttr2 >= 0 && stbl2 >= 0)
                    {

                            if(Wall_ID[z] == 2)
                            {
                                if(DotProduct(Down(),DirectionTowards(fullbodypos,filterpos))>0)
                                {
                                    if(active_wall[z] == false)
                                    {
                                       is_Grounded = true;

                                        SetGravity(eventPlayer,0);
                                        active_wall[z] = 1;
                                        ApplyImpulse(eventPlayer, Up(), 0.001);
                                        ApplyImpulse(eventPlayer, Down(), 0.001);
                                        if(HorizontalSpeedOf()>0.01)
                                        {
                                            ApplyImpulse(eventPlayer, Left(), 0.001);
                                            ApplyImpulse(eventPlayer, Right(), 0.001);
                                            ApplyImpulse(eventPlayer, Forward(), 0.001);
                                            ApplyImpulse(eventPlayer, Backward(), 0.001);
                                        }
                                    }

                                        // if(!IsUsingAbility1()||!IsUsingAbility2()||!IsFiringSecondary()&&SpeedOf()<0.01)
                                        // SetMoveSpeed(eventPlayer,1000);
                                        // else
                                        // SetMoveSpeed(eventPlayer,100);

                                    // if(closestbodypos == firstpos[z])
                                    // {
                                    //  horizontal_intersection = fullbodypos + AllDir[z] * DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(AllDir[z], AllDir[z]);
                                    // ApplyImpulse(eventPlayer, DirectionTowards(horizontal_intersection,fullbodypos) * Vector(1,0,1), 0.001);
                                    // }


                                     if(IsButtonHeld(eventPlayer,Button.Jump))
                                     ApplyImpulse(eventPlayer, Up(), 5.5);

                                    if(ThrottleOf() != Vector(0,0,0))
                                    {
                                    ApplyImpulse(eventPlayer, CrossProduct(Up(),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))  , 0.001);
                                    ApplyImpulse(eventPlayer, CrossProduct(Down(),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))) , 0.001);
                                    ApplyImpulse(eventPlayer, DirectionTowards(EyePosition(),EyePosition() + Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)) * 1)  , 3);
                                    }

                                    if(ThrottleOf() == Vector(0,0,0) && HorizontalSpeedOf()>0.01)
                                        {
                                            ApplyImpulse(eventPlayer, Left(), 0.001);
                                            ApplyImpulse(eventPlayer, Right(), 0.001);
                                            ApplyImpulse(eventPlayer, Forward(), 0.001);
                                            ApplyImpulse(eventPlayer, Backward(), 0.001);
                                        }

                                }
                                else
                                {
                                    ApplyImpulse(eventPlayer, Down(), 0.001);
                                }

                                //StartThrottleInDirection(eventPlayer,null,false,Relative.ToWorld,ThrottleBehavior.AddToExistingThrottle,ThrottleRev.None);
                            }
                            else if(Wall_ID[z] == 6)
                            {
                                 if(active_wall[z] == false)
                                    {
                                        active_wall[z] = 1;
                                        DisableMovementCollisionWithEnvironment(eventPlayer,true);
                                    }
                                    inEraser[z] = true;

                            }
                            else if(Wall_ID[z] == 7)
                            {
                                if(DotProduct(Down(),DirectionTowards(fullbodypos,filterpos))>=0)
                                {
                                     if(IsButtonHeld(eventPlayer,Button.Jump))
                                     ApplyImpulse(eventPlayer, Up(), 5.5);
                                    if(active_wall[z] == false)
                                    {
                                        active_wall[z] = 1;
                                        SetGravity(eventPlayer,0);
                                    }
                                      ApplyImpulse(eventPlayer, Up(), 0.001);
                                }
                                else
                                {
                                    ApplyImpulse(eventPlayer, Down(), 0.001);
                                }
                            }

                    }
                    else
                    {
                        active_wall[z] = 0;
                        is_Grounded = false;
                        inEraser[z] = false;
                        //SetGravity(eventPlayer,100);
                    }
                }
                else if(Wall_ID[z] == 4 || Wall_ID[z] == 8) //sloped wall
                {

                     closestbodypos = PositionOf()+Vector(0,0.5,0);
                    fullbodypos = Vector(XOf(EyePosition()),YOf(closestbodypos),ZOf(EyePosition()));
                    filterpos = fullbodypos + AllDir[z] * DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(AllDir[z], AllDir[z]);


                        if((DotProduct(DirectionTowards(AllPos[z],lastsavedpos),AllDir[z]) > 0) != (DotProduct(DirectionTowards(AllPos[z],fullbodypos),AllDir[z]) > 0))
                        {

                             define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(DirectionTowards(lastsavedpos,fullbodypos) , AllDir[z]);
                               prevpos_intersection = RayCastHitPosition(fullbodypos,fullbodypos + (DirectionTowards(lastsavedpos,fullbodypos)) * intersection_length);
                                    if(fttr2_prev_pos >= 0 && ftbl2_prev_pos >= 0 && sttr2_prev_pos >= 0 && stbl2_prev_pos >= 0)
                                    {
                                  define  velocitySlope = DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(VelocityOf(),DirectionTowards(firstpos[z],secondpoint2[z]));
                                    Teleport(eventPlayer, RayCastHitPosition(prevpos_intersection,prevpos_intersection + DirectionTowards(prevpos_intersection,lastsavedpos) * Vector(1,0,1) * 1));
                                    ApplyImpulse(eventPlayer,AllDir[z],0.001,Relative.ToWorld,ContraryMotion.CancelXYZ);
                                    if(HeroOf(eventPlayer) == Hero.Doomfist && IsUsingAbility2())
                                    {
                                        Teleport(eventPlayer, NearestWalkablePosition(prevpos_intersection));
                                        Wait(0.016);
                                        Teleport(eventPlayer, RayCastHitPosition(prevpos_intersection,prevpos_intersection + Up() * 1));
                                        CancelPrimaryAction();
                                    }
                                    else if(HeroOf(eventPlayer) == Hero.WreckingBall)
                                    {
                                        CancelPrimaryAction();
                                        Teleport(eventPlayer, NearestWalkablePosition(prevpos_intersection));
                                        Wait(0.016);
                                        Teleport(eventPlayer, RayCastHitPosition(prevpos_intersection,prevpos_intersection + Up() * 1));
                                    }
                                    SetFacing(eventPlayer,prev_facingdir);
                                    //SetStatus(eventPlayer,null,Status.Stunned,0.001);
                                    // define downwardslope = DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(Down(),DirectionTowards(firstpos[z],secondpoint2[z]));
                                    //define velocitySlope = DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(VelocityOf(),DirectionTowards(firstpos[z],secondpoint2[z]));
                                    //ApplyImpulse(eventPlayer,AllDir[z],0.001);
                                    //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                    //SmallMessage(eventPlayer,"gravity");

                                    }

                        }







                    if(DistanceBetween(filterpos,fullbodypos)<=1 &&fttr2 >= 0 && ftbl2 >= 0 && sttr2 >= 0 && stbl2 >= 0)
                    {


                                //ApplyImpulse(eventPlayer, Left(), 0.001);
                               //ApplyImpulse(eventPlayer, Right(), 0.001);
                              //ApplyImpulse(eventPlayer, Forward(), 0.001);
                             //ApplyImpulse(eventPlayer, Backward(), 0.001);d
                            //ApplyImpulse(eventPlayer, Up(), 0.001);
                           // ApplyImpulse(eventPlayer, DirectionTowards(firstpos[z],secondpoint2[z]), 1);
                           //ApplyImpulse(eventPlayer, Up(), 0.001);


                            if(DotProduct(Up(),DirectionTowards(filterpos,closestbodypos))>0)
                               {

                                if(active_wall[z] == false)
                                    {
                                        active_wall[z] = true;
                                    }

                                // downwardslope = DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(Down(),DirectionTowards(firstpos[z],secondpoint2[z]));
                                //  velocitySlope = DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(VelocityOf(),DirectionTowards(firstpos[z],secondpoint2[z]));
                               // side_velocitySlope = DirectionTowards(firstpos[z],firstpoint2[z]) * DotProduct(VelocityOf(),DirectionTowards(firstpos[z],firstpoint2[z]));
                                //  //aim_velocitySlope =  DirectionTowards(firstpos[z],secondpoint2[z]) * DotProduct(FacingDirectionOf(),DirectionTowards(firstpos[z],secondpoint2[z]));

                                //                 //ForceThrottle(eventPlayer,0,0,0,0,0,0);
                                //                 SetGravity(eventPlayer,0);

                                //                // ApplyImpulse(eventPlayer,-VelocityOf(),0.001);
                                //                 active_wall[z] = 1;
                                //     }


                                //ApplyImpulse(eventPlayer,Up(),0.001);
                                ApplyImpulse(eventPlayer,AllDir[z],0.001,Relative.ToWorld,ContraryMotion.CancelXYZ);
                                 //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                 if(strafeToggle)
                                {
                                if(Wall_ID[z] == 4)
                                max_horizontal_speed = max_horizontal_speed + 0.1 * 0.016;
                                else
                                max_horizontal_speed = max_horizontal_speed + SpeedOfInDirection(eventPlayer,Down()) * 0.016;

                                current_Slope_Dir = AllDir[z];
                                }

                                //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),max_horizontal_speed);

                               // if(DotProduct(AllDir[z] * Vector(1,0,1),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))) < 0 )
                               // {

                                //ApplyImpulse(eventPlayer,side_velocitySlope,SpeedOf());
                                //ApplyImpulse(eventPlayer,aim_velocitySlope,SpeedOf() / 5);
                                //StartAccelerating(eventPlayer,aim_velocitySlope,100,1000,Relative.ToWorld,AccelerateRev.None)
                                //max_horizontal_speed = max_horizontal_speed - (decel_speed * 0.016);
                                //ApplyImpulse(eventPlayer,Vector(XOf(side_velocitySlope),YOf(velocitySlope),ZOf(side_velocitySlope)),SpeedOf());
                               // }



                                // else
                                // {
                                // ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),HorizontalSpeedOf());
                                // //StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])),1000,Relative.ToWorld,AccelerateRev.None)
                                // }
                                // // else if(DotProduct(AllDir[z] * Vector(1,0,1),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))) > 0 )
                                // // {
                                // // ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(downwardslope),ZOf(VelocityOf())),HorizontalSpeedOf());
                                // // StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])),1000,Relative.ToWorld,AccelerateRev.None)
                                // // }
                                // else
                                // {
                                //     if(DotProduct(VelocityOf(),downwardslope)>=0) //going down
                                //     {
                                //     //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                //     ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                //     StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])),1000,Relative.ToWorld,AccelerateRev.None)
                                //     }
                                //     if(DotProduct(VelocityOf(),downwardslope)<0) //going up
                                //     {
                                //     ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),0,ZOf(VelocityOf())) ,SpeedOf());
                                //     //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),HorizontalSpeedOf());
                                //     //ApplyImpulse(eventPlayer, downwardslope,(SpeedOf()+(70*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[0]))))*0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                                //     StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])),1000,Relative.ToWorld,AccelerateRev.None)
                                //     }
                                // }
                                // if(ThrottleOf() != Vector(0,0,0))
                                // {
                                // if(SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])) > 10)
                                //  ApplyImpulse(eventPlayer, downwardslope,(SpeedOf() * SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[z])))*0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                                //  else
                                //  ApplyImpulse(eventPlayer, downwardslope,SpeedOf() * 0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                                // }

                              }
                              else
                              {
                                     ApplyImpulse(eventPlayer,DirectionTowards(filterpos,fullbodypos),0.001);
                              }

                    }
                    else
                    {
                    active_wall[z] = 0;
                    }
                }

                else if(Wall_ID[z] == 9) //Sphere
                {
                     define dir = DirectionTowards(AllPos[z] + DirectionTowards(AllPos[z],eventPlayer) * sphereRadius[z],eventPlayer) ;
                     if((DotProduct(DirectionTowards(AllPos[z],lastsavedpos),dir) > 0) != (DotProduct(DirectionTowards(AllPos[z],eventPlayer),dir) > 0))
                        {
                            define intersection_length = DotProduct(AllPos[z] - eventPlayer,dir) / DotProduct(DirectionTowards(lastsavedpos,eventPlayer) , dir);
                               prevpos_intersection = RayCastHitPosition(eventPlayer,eventPlayer + (DirectionTowards(lastsavedpos,eventPlayer)) * intersection_length);

                                    Teleport(eventPlayer, RayCastHitPosition(prevpos_intersection,prevpos_intersection + DirectionTowards(prevpos_intersection,lastsavedpos) * 1));

                                    ApplyImpulse(eventPlayer,dir,0.001,Relative.ToWorld,ContraryMotion.CancelXYZ);



                        }

                    if(DistanceBetween(eventPlayer,AllPos[z] + DirectionTowards(AllPos[z],eventPlayer) * sphereRadius[z])<1)
                    {


                        // define downwardslope = CrossProduct(CrossProduct(Up(),dir),dir) * DotProduct(Down(),CrossProduct(CrossProduct(Up(),dir),dir));
                        // define velocitySlope = CrossProduct(CrossProduct(Up(),dir),dir) * DotProduct(VelocityOf(),CrossProduct(CrossProduct(Up(),dir),dir));

                                    // if(CountOf(FilteredArray(active_wall,ArrayElement() == 1)) == 0)
                                    // {
                                    //             //ForceThrottle(eventPlayer,0,0,0,0,0,0);
                                    //             SetGravity(eventPlayer,0);
                                    //             //ApplyImpulse(eventPlayer,dir,0.001);
                                    //            // ApplyImpulse(eventPlayer,-VelocityOf(),0.001);
                                    //             active_wall[z] = 1;
                                    // }
                               ApplyImpulse(eventPlayer,dir,1,Relative.ToWorld,ContraryMotion.CancelXYZ);
                               //ApplyImpulse(eventPlayer,Up(),0.001);
                            //    ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                            //     StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)),1000,Relative.ToWorld,AccelerateRev.None)
                            //     ApplyImpulse(eventPlayer, downwardslope,(SpeedOf() * SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)))*0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                                //ApplyImpulse(eventPlayer,Up(),0.001);
                                 //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());

                                // if(DotProduct(VelocityOf(),downwardslope)>=0)
                                // {
                                // //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                // ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),SpeedOf());
                                // StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)),1000,Relative.ToWorld,AccelerateRev.None)
                                // }
                                // else if(DotProduct(VelocityOf(),downwardslope)<0 && ThrottleOf()!=Vector())
                                // {
                                // ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())) ,SpeedOf());
                                // //ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),HorizontalSpeedOf());
                                // //ApplyImpulse(eventPlayer, downwardslope,(SpeedOf()+(70*SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[0]))))*0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                                // StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)),1000,Relative.ToWorld,AccelerateRev.None)
                                // }
                                // else if(DotProduct(VelocityOf(),downwardslope)<0 && ThrottleOf()==Vector())
                                // {
                                // ApplyImpulse(eventPlayer,Vector(XOf(VelocityOf()),YOf(velocitySlope),ZOf(VelocityOf())),HorizontalSpeedOf());
                                // StartAccelerating(eventPlayer,downwardslope,17.5*SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)),1000,Relative.ToWorld,AccelerateRev.None)
                                // }
                                //  ApplyImpulse(eventPlayer, downwardslope,(SpeedOf() * SineFromDegrees(AngleBetweenVectors(Down(),-1  * Dir)))*0.016,Relative.ToWorld,ContraryMotion.Incorporate);
                    }
                    else
                    {
                    active_wall[z] = 0;
                    }
                }
            }
         }
         else
         {
          fullbodypos = PositionOf();
            for( z =0; CountOf(AllPos);1)
            {
            lastsavedpos = fullbodypos;
            }
         }

    Loop();
    //LoopIfConditionIsTrue()

}

rule: "Arcball Mode"
Event.OngoingPlayer
if(arcballMode)
{
StartCamera(eventPlayer,RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * 1), point,20);
define outercampos = RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * 1);
StartForcingPlayerPosition(eventPlayer,PositionOf(),false);
openui = false;
while(arcballMode)
{
    outercampos = point;

    Wait(0.016);

    if(ThrottleOf() != Vector())
    {

         if(!IsInLineOfSight(point,RayCastHitPosition(point,point + Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))) * -0.1)) || point == RayCastHitPosition(point,point + Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))) * -0.1))
         {
             define hitnormal = RayCastHitNormal(point,point + Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))) * -0.1);
            define undesiredMotion = hitnormal * DotProduct(Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))),hitnormal);
            define desiredMotion = Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))) - undesiredMotion;
           point = RayCastHitPosition(point,point + desiredMotion * -0.05);
         }
         else
        point = RayCastHitPosition(point,point + Vector(XOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))),YOf(FacingDirectionOf() * Vector(1,-1,1)),ZOf(Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))) * -0.05);
    }
    // if(ThrottleOf() == Vector(0,0,1))
    // {
    //     if(point == RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * -0.05))
    //     point = RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,0,1) * -0.05);
    //     else
    //     point = RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * -0.05);
    // }
    // if(ThrottleOf() == Vector(0,0,-1))
    // {
    //     if(point == RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * 0.05))
    //     point = RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,0,1) * 0.05);
    //     else
    //     point = RayCastHitPosition(point,point + FacingDirectionOf() * Vector(1,-1,1) * 0.05);
    // }
    // if(ThrottleOf() == Vector(1,0,0))
    // {
    //     point = RayCastHitPosition(point,point + CrossProduct(Down(),FacingDirectionOf()* Vector(1,-1,1)) * 0.05);
    //     SmallMessage(eventPlayer,"fwef");
    // }
    // if(ThrottleOf() == Vector(-1,0,0))
    //     point = RayCastHitPosition(point,point + CrossProduct(Up(),FacingDirectionOf()* Vector(1,-1,1)) * 0.05);
    if(IsButtonHeld(eventPlayer,Button.Jump))
        point = RayCastHitPosition(point,point + Up() * 0.05);
    if(IsButtonHeld(eventPlayer,Button.Crouch))
        point = RayCastHitPosition(point,point + Down() * 0.05);
    if(IsButtonHeld(eventPlayer,Button.Reload))
    {
        arcballMode = false;
        break;
    }


}
StopCamera();
StopForcingPlayerPosition();
}



rule: "Cursor"
Event.OngoingPlayer
if(openui == false && arcballMode == false)
{
    lastmousepos = FacingDirectionOf();
    MinWait();

    //if(arcballMode)
    //arcBallScript()

    define closest_beam_firstpos!;
    define closest_beam_secondpos!;
    define closest_beam_firstpoint2!;
    define closest_beam_secondpoint2!;
    if(cursor_snap_Tool == 2)
    {
        for(define x = 0; CountOf(AllPos); 1)
        {
            if(Wall_ID[x] == 1 || Wall_ID[x] == 3 || Wall_ID[x] == 5)
            {
            all_beam_intersection[x * 4] = firstpos[x] + DirectionTowards(firstpos[x],secondpoint2[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - firstpos[x],CrossProduct(Up(),FacingDirectionOf())) / DotProduct(DirectionTowards(firstpos[x],secondpoint2[x]),CrossProduct(Up(),FacingDirectionOf()));
            beam_dir[x * 4] = DirectionTowards(firstpos[x],secondpoint2[x]);
            all_beam_intersection[x * 4 + 1] = secondpoint2[x] + DirectionTowards(secondpoint2[x],secondpos[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - secondpoint2[x],CrossProduct(FacingDirectionOf(),CrossProduct(Up(),FacingDirectionOf()))) / DotProduct(DirectionTowards(secondpoint2[x],secondpos[x]),CrossProduct(FacingDirectionOf(),CrossProduct(Up(),FacingDirectionOf())));
            beam_dir[x * 4 + 1] = DirectionTowards(secondpoint2[x],secondpos[x]);
            all_beam_intersection[x * 4 + 2] = secondpos[x] + DirectionTowards(secondpos[x],firstpoint2[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - secondpos[x],CrossProduct(Down(),FacingDirectionOf())) / DotProduct(DirectionTowards(secondpos[x],firstpoint2[x]),CrossProduct(Down(),FacingDirectionOf()));
            beam_dir[x * 4 + 2] = DirectionTowards(secondpos[x],firstpoint2[x]);
            all_beam_intersection[x * 4 + 3] = firstpoint2[x] + DirectionTowards(firstpoint2[x],firstpos[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - firstpoint2[x],CrossProduct(FacingDirectionOf(),CrossProduct(Down(),FacingDirectionOf()))) / DotProduct(DirectionTowards(firstpoint2[x],firstpos[x]),CrossProduct(FacingDirectionOf(),CrossProduct(Down(),FacingDirectionOf())));
            beam_dir[x * 4 + 3] = DirectionTowards(firstpoint2[x],firstpos[x]);
            }
            else if(Wall_ID[x] == 2 || Wall_ID[x] == 6 || Wall_ID[x] == 7 || Wall_ID[x] == 4 || Wall_ID[x] == 8)
            {
            all_beam_intersection[x * 4] = firstpos[x] + DirectionTowards(firstpos[x],secondpoint2[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - firstpos[x],CrossProduct(Up(),FacingDirectionOf())) / DotProduct(DirectionTowards(firstpos[x],secondpoint2[x]),CrossProduct(Up(),FacingDirectionOf()));
            beam_dir[x * 4] = DirectionTowards(firstpos[x],secondpoint2[x]);
            all_beam_intersection[x * 4 + 1] = secondpoint2[x] + DirectionTowards(secondpoint2[x],secondpos[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - secondpoint2[x],CrossProduct(Up(),FacingDirectionOf())) / DotProduct(DirectionTowards(secondpoint2[x],secondpos[x]),CrossProduct(Up(),FacingDirectionOf()));
            beam_dir[x * 4 + 1] = DirectionTowards(secondpoint2[x],secondpos[x]);
            all_beam_intersection[x * 4 + 2] = secondpos[x] + DirectionTowards(secondpos[x],firstpoint2[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - secondpos[x],CrossProduct(Down(),FacingDirectionOf())) / DotProduct(DirectionTowards(secondpos[x],firstpoint2[x]),CrossProduct(Down(),FacingDirectionOf()));
            beam_dir[x * 4 + 2] = DirectionTowards(secondpos[x],firstpoint2[x]);
            all_beam_intersection[x * 4 + 3] = firstpoint2[x] + DirectionTowards(firstpoint2[x],firstpos[x]) *  DotProduct(RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5) - firstpoint2[x],CrossProduct(Up(),FacingDirectionOf())) / DotProduct(DirectionTowards(firstpoint2[x],firstpos[x]),CrossProduct(Up(),FacingDirectionOf()));
            beam_dir[x * 4 + 3] = DirectionTowards(firstpoint2[x],firstpos[x]);
            }

        }
    }

    if(cursor_snap_Tool == 1 || cursor_snap_Tool == 2)
    {
     closest_firstpos = FirstOf(SortedArray(FilteredArray(firstpos,IsInLineOfSight(ArrayElement(),EyePosition())),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
     closest_secondpos = FirstOf(SortedArray(FilteredArray(secondpos,IsInLineOfSight(ArrayElement(),EyePosition())),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
     closest_firstpoint2 = FirstOf(SortedArray(FilteredArray(firstpoint2,IsInLineOfSight(ArrayElement(),EyePosition())),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
     closest_secondpoint2 = FirstOf(SortedArray(FilteredArray(secondpoint2,IsInLineOfSight(ArrayElement(),EyePosition())),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
    }

     AllVertices = [
        closest_firstpos,
        closest_secondpos,
        closest_firstpoint2,
        closest_secondpoint2,
        (closest_firstpos + closest_secondpoint2) /2,
        (closest_secondpoint2 + closest_secondpos) /2,
        (closest_secondpos + closest_firstpoint2) /2,
        (closest_firstpoint2 + closest_firstpos) /2
        ];

         if(cursor_snap_Tool == 1 || cursor_snap_Tool == 2)
         closestvertices = FirstOf(SortedArray(AllVertices,DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
        if(cursor_snap_Tool == 2)
         closest_beam_intersection = FirstOf(SortedArray(FilteredArray(all_beam_intersection,IsInLineOfSight(EyePosition(),ArrayElement())),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));

            //radius = 0.1 * DistanceBetween(closestvertices,EyePosition()) * 0.2;
            if(CountOf(AllPos)==0)
            {
                point = RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5);
                radius = 0.1;
            }
            else if((cursor_snap_Tool == 1 || cursor_snap_Tool == 2) && DistanceBetween(EyePosition()+FacingDirectionOf() * DistanceBetween(closestvertices,EyePosition()),closestvertices) < (0.12/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(closestvertices,EyePosition())))
            {
                    point = closestvertices;
                    radius = (0.12/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(closestvertices,EyePosition()));
            }
            else if(cursor_snap_Tool == 2 && DistanceBetween(EyePosition()+FacingDirectionOf() * DistanceBetween(closest_beam_intersection,EyePosition()),closest_beam_intersection) < (0.1/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(closest_beam_intersection,EyePosition())))
            {
                point = closest_beam_intersection;
                radius = (0.12/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(closest_beam_intersection,EyePosition()));
            }

            else
            {

                radius = 0.1;
                point = RayCastHitPosition(EyePosition(),EyePosition() + FacingDirectionOf() * 5);

            }

            LoopIfConditionIsTrue();
}

// rule: "Reset"
// Event.OngoingPlayer
// if(IsTrueForAny(active_wall,ArrayElement()) == true)
// {
//     StartThrottleInDirection(eventPlayer,null,false,Relative.ToWorld,ThrottleBehavior.AddToExistingThrottle,ThrottleRev.None);
//     MinWait();
//     LoopIfConditionIsTrue();
// }

rule: "Disables stuff"
Event.OngoingPlayer
if(CountOf(FilteredArray(active_wall,ArrayElement()!=0)) == 0)
{
     if(flymode == false)
     SetGravity(eventPlayer,100);
     StopForcingThrottle(eventPlayer);
     StopAccelerating();
     if(strafeToggle)
     DisableMovementCollisionWithEnvironment();
     else
     EnableMovementCollisionWithEnvironment();
}

rule: "Disable Inspector Recording"
Event.OngoingGlobal
{
    DisableInspectorRecording();
    PauseMatchTime();
}


//Vertical Wall
rule: "All Vertical Walls"
Event.OngoingPlayer
if(ArrayContains([1,3,5],UI_ID) && IsButtonHeld(eventPlayer,Button.Interact))
{

    if(CountOf(vertical_points)==0)
        {
            CreateInWorldText(AllPlayers(),DistanceBetween(vertical_points[0],Vector(XOf(point),YOf(vertical_points[0]),ZOf(point))),point,1,Clipping.DoNotClip);
            measureTextEntity[0]  = LastTextID();
        }
    vertical_points[CountOf(vertical_points)] = point;
    CreateEffect(AllPlayers(),Effect.Sphere,Color.Red,LastOf(vertical_points),0.1,EffectRev.VisibleTo);
    horizontal_effect_id[CountOf(horizontal_effect_id)] = LastCreatedEntity();
    Wait(0.3);
    if(CountOf(vertical_points)==2)
    {

        define s = Vector(XOf(vertical_points[1]),YOf(vertical_points[0]),ZOf(vertical_points[1]));
        define beams;
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,vertical_points[0], s+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
        beams[CountOf(beams)] = LastCreatedEntity();

            DestroyInWorldText(measureTextEntity[0]);

        CreateInWorldText(AllPlayers(),DistanceBetween(vertical_points[0],vertical_points[1]),(vertical_points[0]+vertical_points[1])/2,1,Clipping.DoNotClip);
        measureTextEntity[CountOf(measureTextEntity)]  = LastTextID();

        CreateInWorldText(AllPlayers(),DistanceBetween(vertical_points[1],second),(vertical_points[1]+second)/2 + Vector(0,-0.5,0),1,Clipping.DoNotClip);
        measureTextEntity[CountOf(measureTextEntity)] = LastTextID();
        Wait(0.016);

        WaitUntil(!IsButtonHeld(eventPlayer,Button.Interact),999999);

        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,s + Vector(0.001,0,0), second,Color.Aqua,EffectRev.VisibleToPositionAndRadius);
        beams[CountOf(beams)] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + Vector(0.001,0,0), second + ((DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1)) * -1)*DistanceBetween(vertical_points[0],vertical_points[1]),Color.Aqua,EffectRev.VisibleToPositionAndRadius);
        beams[CountOf(beams)] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]), vertical_points[0]+ Vector(0.001,0,0),Color.Aqua,EffectRev.VisibleToPositionAndRadius);
        beams[CountOf(beams)] = LastCreatedEntity();

        while(IsButtonHeld(eventPlayer,Button.Interact) == false)
        {
        //second = s + CrossProduct(DirectionTowards(horizontal_points[0],s),Up()) * (DistanceBetween(horizontal_points[0],point) * -1  * DotProduct(CrossProduct(DirectionTowards(horizontal_points[0],horizontal_points[1]),Up()) * Vector(1,0,1), DirectionTowards(point, horizontal_points[1])));
        second = s + DirectionTowards(vertical_points[0],point) * Vector(0,1,0) * DistanceBetween(vertical_points[0],point);
        Wait(0.016);
        }
            lastsavedpos[CountOf(lastsavedpos)] = PositionOf();
            firstpos[CountOf(firstpos)] = vertical_points[0];
            secondpoint2[CountOf(secondpoint2)] = s;
            firstpoint2[CountOf(firstpoint2)] = second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]);
            secondpos[CountOf(secondpos)] = second;

            AllPos[CountOf(AllPos)] = (firstpos[CountOf(firstpos)-1] + second)/2;
            AllDir[CountOf(AllDir)] = CrossProduct(Down(),DirectionTowards(firstpos[CountOf(firstpos)-1],s)) * Vector(1,0,1);

            Wall_ID[CountOf(Wall_ID)] = UI_ID;
            g_beamType[CountOf(g_beamType)] = beamType;
            DestroyEffect(beams[0]);
            DestroyEffect(beams[1]);
            DestroyEffect(beams[2]);
            DestroyEffect(beams[3]);
            DestroyEffect(horizontal_effect_id[0]);
            DestroyEffect(horizontal_effect_id[1]);

            if(UI_ID==1 || UI_ID==3)
            {
                // if(UI_ID==0)
                // {
                // CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Yellow, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
                // beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                // }
                // else if(UI_ID==2)
                // {
                // CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Purple, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
                //  beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                // }
                switch(beamType)
                {
                    case 1:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,vertical_points[0], s+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,s + Vector(0.001,0,0), second+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + Vector(0.001,0,0), second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]), vertical_points[0]+ Vector(0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;

                    case 2:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,vertical_points[0], s+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,s + Vector(0.001,0,0), second+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second + Vector(0.001,0,0), second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]), vertical_points[0]+ Vector(0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;

                    case 3:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,vertical_points[0], s+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,s + Vector(0.001,0,0), second+ Vector(-0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second + Vector(0.001,0,0), second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]), vertical_points[0]+ Vector(0.001,0,0),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;
                }
            }
            else if(UI_ID==5)
            {
        //CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Yellow, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
        //beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,vertical_points[0], s+ Vector(-0.001,0,0),Color.Red,EffectRev.VisibleTo);
        beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,s + Vector(0.001,0,0), second+ Vector(-0.001,0,0),Color.Red,EffectRev.VisibleTo);
        beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second + Vector(0.001,0,0), second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]),Color.Red,EffectRev.VisibleTo);
        beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
        CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second + -1*(DirectionTowards(vertical_points[0],vertical_points[1])* Vector(1,0,1))*DistanceBetween(vertical_points[0],vertical_points[1]), vertical_points[0]+ Vector(0.001,0,0),Color.Red,EffectRev.VisibleTo);
        beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();

            }
        vertical_points = EmptyArray();
        horizontal_effect_id = EmptyArray();

        for(define tempcount =0;3;1)
            {
                DestroyInWorldText(measureTextEntity[tempcount]);
            }

            measureTextEntity = EmptyArray();
        }
   // Wait(0.3);

}







//Horizontal Wall
rule: "All Horizontal Wall"
Event.OngoingPlayer
if(ArrayContains([2,6,7],UI_ID)&& IsButtonHeld(eventPlayer,Button.Interact))
{
    if(CountOf(horizontal_points)==0)
    {
        CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],Vector(XOf(point),YOf(horizontal_points[0]),ZOf(point))),point,1,Clipping.DoNotClip);
        measureTextEntity[0]  = LastTextID();
    }

        horizontal_points[CountOf(horizontal_points)] = point;
        CreateEffect(AllPlayers(),Effect.Sphere,Color.Red,horizontal_points[CountOf(horizontal_points)-1],0.1,EffectRev.VisibleTo);
        horizontal_effect_id[CountOf(horizontal_effect_id)] = LastCreatedEntity();
        Wait(0.3);
        if(CountOf(horizontal_points)==2)
        {
            DestroyInWorldText(measureTextEntity[0]);
            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],horizontal_points[1]),(horizontal_points[0]+horizontal_points[1])/2,1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)]  = LastTextID();

            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[1],second),(horizontal_points[1]+second)/2 + Vector(0,-0.5,0),1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)] = LastTextID();
            Wait(0.016);

            define s = Vector(XOf(horizontal_points[1]),YOf(horizontal_points[0]),ZOf(horizontal_points[1]));
            define beams;
            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], s,Color.Aqua,EffectRev.VisibleTo);
            beams[CountOf(beams)] = LastCreatedEntity();
            WaitUntil(!IsButtonHeld(eventPlayer,Button.Interact),999999);

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,s, second,Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]),Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]), horizontal_points[0],Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            while(IsButtonHeld(eventPlayer,Button.Interact) == false)
            {
            //second = s + CrossProduct(DirectionTowards(horizontal_points[0],s),Up()) * (DistanceBetween(horizontal_points[0],point) * -1  * DotProduct(CrossProduct(DirectionTowards(horizontal_points[0],horizontal_points[1]),Up()) * Vector(1,0,1), DirectionTowards(point, horizontal_points[1])));
           second = s + CrossProduct(DirectionTowards(horizontal_points[0],s),CrossProduct(DirectionTowards(horizontal_points[0],s),-1  * DirectionTowards(horizontal_points[0],point)*Vector(1,0,1))) * (DistanceBetween(horizontal_points[0],point) );
           Wait(0.016);
            }

            firstpos[CountOf(firstpos)] = horizontal_points[0];
            secondpos[CountOf(secondpos)] = second;
            firstpoint2[CountOf(firstpoint2)] = s;
            secondpoint2[CountOf(secondpoint2)] = second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]);
            DestroyEffect(beams[0]);
            DestroyEffect(beams[1]);
            DestroyEffect(beams[2]);
            DestroyEffect(beams[3]);
            DestroyEffect(horizontal_effect_id[0]);
            DestroyEffect(horizontal_effect_id[1]);

            AllPos[CountOf(AllPos)] = (horizontal_points[0] + second)/2;

            //AllDir[CountOf(AllDir)] = CrossProduct(Left(),DirectionTowards(horizontal_points[0],firstpoint2[CountOf(firstpoint2)-1]));
            AllDir[CountOf(AllDir)] = Up();
            Wall_ID[CountOf(Wall_ID)] = UI_ID;
             g_beamType[CountOf(g_beamType)] = beamType;
            if(UI_ID==2 || UI_ID==7)
            {
                switch(beamType)
                {
                    case 1:
                     //CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Yellow, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
                     //beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,firstpoint2[CountOf(firstpoint2)-1], second,Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, secondpoint2[CountOf(secondpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,secondpoint2[CountOf(secondpoint2)-1], horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                     break;

                     case 2:
                     //CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Yellow, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
                     //beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,firstpoint2[CountOf(firstpoint2)-1], second,Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second, secondpoint2[CountOf(secondpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,secondpoint2[CountOf(secondpoint2)-1], horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                     break;

                     case 3:
                     //CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Yellow, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
                     //beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,firstpoint2[CountOf(firstpoint2)-1], second,Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second, secondpoint2[CountOf(secondpoint2)-1],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,secondpoint2[CountOf(secondpoint2)-1], horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                     beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                     break;
                }
            }
            else if(UI_ID==6)
            {
            //CreateEffect(FilteredArray(AllPlayers(),showwalls == true),Effect.Sphere,Color.Green, (firstpos[CountOf(firstpos)-1]+second)/2,0.1,EffectRev.VisibleTo);
            //beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1],Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
              CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,firstpoint2[CountOf(firstpoint2)-1], second,Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

             CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second, secondpoint2[CountOf(secondpoint2)-1],Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

             CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,secondpoint2[CountOf(secondpoint2)-1], horizontal_points[0],Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            }


            horizontal_points = EmptyArray();
            horizontal_effect_id = EmptyArray();

            for(define tempcount =0;3;1)
            {
                DestroyInWorldText(measureTextEntity[tempcount]);
            }

            measureTextEntity = EmptyArray();
            //Wait(0.3);

        }

}



//Sloped Wall
rule: "Slope Wall"
Event.OngoingPlayer
if(IsButtonHeld(eventPlayer,Button.Interact) && UI_ID == 4)
{
    if(CountOf(horizontal_points)==0)
    {
        CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],Vector(XOf(point),YOf(horizontal_points[0]),ZOf(point))),point,1,Clipping.DoNotClip);
        measureTextEntity[0]  = LastTextID();
    }

        horizontal_points[CountOf(horizontal_points)] = point;
        CreateEffect(AllPlayers(),Effect.Sphere,Color.Red,horizontal_points[CountOf(horizontal_points)-1],0.1,EffectRev.VisibleTo);
        horizontal_effect_id[CountOf(horizontal_effect_id)] = LastCreatedEntity();
        Wait(0.3);
        if(CountOf(horizontal_points)==2)
        {
            define angle;
            define seconds;
            DestroyInWorldText(measureTextEntity[0]);
            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],horizontal_points[1]),(horizontal_points[0]+horizontal_points[1])/2,1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)]  = LastTextID();

            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[1],second),(horizontal_points[1]+second)/2 + Vector(0,-0.5,0),1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)] = LastTextID();

            CreateInWorldText(AllPlayers(),<"<0>°",angle>,horizontal_points[0] + Vector(0,-1,0),1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)] = LastTextID();
            Wait(0.016);

            define s = Vector(XOf(horizontal_points[1]),YOf(horizontal_points[0]),ZOf(horizontal_points[1]));
            define beams;

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], s,Color.Aqua,EffectRev.VisibleTo);
            beams[CountOf(beams)] = LastCreatedEntity();
            WaitUntil(!IsButtonHeld(eventPlayer,Button.Interact),999999);

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,s, second,Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]),Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]), horizontal_points[0],Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            while(IsButtonHeld(eventPlayer,Button.Interact) == false)
            {
            second = s + CrossProduct(DirectionTowards(horizontal_points[0],s),CrossProduct(DirectionTowards(horizontal_points[0],s),-1  * DirectionTowards(horizontal_points[0],point))) * (DistanceBetween(horizontal_points[0],point) );
            seconds = second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]);
            //angle = AngleBetweenVectors(Down(),-CrossProduct(DirectionTowards(horizontal_points[0],second),DirectionTowards(horizontal_points[0],horizontal_points[1])));
            angle = AngleBetweenVectors(Down(),-1*Normalize(CrossProduct(-1*CrossProduct(DirectionTowards(horizontal_points[0],seconds) * DotProduct(Down(),DirectionTowards(horizontal_points[0],seconds)),Up()),DirectionTowards(horizontal_points[0],seconds) * DotProduct(Up(),DirectionTowards(horizontal_points[0],seconds)))));
            Wait(0.016);
            }

            firstpos[CountOf(firstpos)] = horizontal_points[0];
            secondpos[CountOf(secondpos)] = second;
            firstpoint2[CountOf(firstpoint2)] = s;
            secondpoint2[CountOf(secondpoint2)] = second + -1  * (DirectionTowards(horizontal_points[0],horizontal_points[1])* Vector(1,0,1))*DistanceBetween(horizontal_points[0],horizontal_points[1]);


            DestroyEffect(beams[0]);
            DestroyEffect(beams[1]);
            DestroyEffect(beams[2]);
            DestroyEffect(beams[3]);
            DestroyEffect(horizontal_effect_id[0]);
            DestroyEffect(horizontal_effect_id[1]);

            AllPos[CountOf(AllPos)] = (horizontal_points[0] + second)/2;

            //AllDir[CountOf(AllDir)] = CrossProduct(Left(),DirectionTowards(horizontal_points[0],firstpoint2[CountOf(firstpoint2)-1]));

            //AllDir[CountOf(AllDir)] = -CrossProduct(DirectionTowards(horizontal_points[0],s),DirectionTowards(horizontal_points[0],secondpoint2[CountOf(secondpoint2)-1]));

            AllDir[CountOf(AllDir)] = Normalize(CrossProduct(-1*CrossProduct(DirectionTowards(horizontal_points[0],secondpoint2[CountOf(secondpoint2)-1]) * DotProduct(Down(),DirectionTowards(horizontal_points[0],secondpoint2[CountOf(secondpoint2)-1])),Up()),DirectionTowards(horizontal_points[0],secondpoint2[CountOf(secondpoint2)-1]) * DotProduct(Up(),DirectionTowards(horizontal_points[0],secondpoint2[CountOf(secondpoint2)-1]))));
            Wall_ID[CountOf(Wall_ID)] = UI_ID;
            ///^Slope Normal = Cross(LeftOfSlope, UpOfSlope)
            // if(SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[CountOf(AllDir)-1])) <= 2)
            // {
            // Wall_ID[CountOf(Wall_ID)] = 7;
            // SmallMessage(eventPlayer,"7")
            // }
            // else if(SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[CountOf(AllDir)-1])) >=88)
            // {
            // Wall_ID[CountOf(Wall_ID)] = 1;
            // SmallMessage(eventPlayer,"1");
            //  }
            // else
            // {
            // Wall_ID[CountOf(Wall_ID)] = UI_ID;
            // SmallMessage(eventPlayer,SineFromDegrees(AngleBetweenVectors(Down(),-AllDir[CountOf(AllDir)-1])) * 10000);
            // }

            g_beamType[CountOf(g_beamType)] = beamType;
            //DirectionTowards(firstpos[0],secondpoint2[0]) * DotProduct(Down(),DirectionTowards(firstpos[0],secondpoint2[0]))
            switch(beamType)
            {
                case 1:
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

                 case 2:
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

                 case 3:
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

            }



            horizontal_points = EmptyArray();
            horizontal_effect_id = EmptyArray();

            for(define tempcount =0;4;1)
            {
                DestroyInWorldText(measureTextEntity[tempcount]);
            }

            measureTextEntity = EmptyArray();
            //Wait(0.5);

        }

}




rule: "Angled Slope Wall"   //Angled Sloped Wall
Event.OngoingPlayer
if(IsButtonHeld(eventPlayer,Button.Interact) && UI_ID == 8)
{

    if(CountOf(horizontal_points)==0)
    {
        CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],Vector(XOf(point),YOf(horizontal_points[0]),ZOf(point))),point,1,Clipping.DoNotClip);
        measureTextEntity[0]  = LastTextID();
    }
        horizontal_points[CountOf(horizontal_points)] = point;
        CreateEffect(AllPlayers(),Effect.Sphere,Color.Red,horizontal_points[CountOf(horizontal_points)-1],0.1,EffectRev.VisibleTo);
        horizontal_effect_id[CountOf(horizontal_effect_id)] = LastCreatedEntity();
        Wait(0.3);
        if(CountOf(horizontal_points)==2)
        {

            define angle;
            define seconds;
            define tempdir;
            DestroyInWorldText(measureTextEntity[0]);
            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[0],horizontal_points[1]),(horizontal_points[0]+horizontal_points[1])/2,1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)]  = LastTextID();

            CreateInWorldText(AllPlayers(),DistanceBetween(horizontal_points[1],second),(horizontal_points[1]+second)/2 + Vector(0,-0.5,0),1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)] = LastTextID();

            CreateInWorldText(AllPlayers(),<"<0>°",angle>,horizontal_points[0] + Vector(0,-1,0),1,Clipping.DoNotClip);
            measureTextEntity[CountOf(measureTextEntity)] = LastTextID();
            Wait(0.016);

            define s = horizontal_points[1];
            define beams;
            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], s,Color.Aqua,EffectRev.VisibleTo);
            beams[CountOf(beams)] = LastCreatedEntity();
            WaitUntil(!IsButtonHeld(eventPlayer,Button.Interact),999999);
            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,s, second,Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, second + DirectionTowards(horizontal_points[1], horizontal_points[0]) *DistanceBetween(horizontal_points[0],horizontal_points[1]),Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second + DirectionTowards(horizontal_points[1], horizontal_points[0]) *DistanceBetween(horizontal_points[0],horizontal_points[1]), horizontal_points[0],Color.Aqua,EffectRev.VisibleToPositionAndRadius);
            beams[CountOf(beams)] = LastCreatedEntity();

            while(IsButtonHeld(eventPlayer,Button.Interact) == false)
            {
            second = s + CrossProduct(DirectionTowards(horizontal_points[1],horizontal_points[0]),CrossProduct(DirectionTowards(horizontal_points[1],point),DirectionTowards(horizontal_points[1],horizontal_points[0]))) * (DistanceBetween(horizontal_points[1],point) );
            seconds = second + DirectionTowards(horizontal_points[1], horizontal_points[0]) *DistanceBetween(horizontal_points[0],horizontal_points[1]);
            //angle = AngleBetweenVectors(Down(),-CrossProduct(DirectionTowards(horizontal_points[0],second),DirectionTowards(horizontal_points[0],horizontal_points[1])));
            //tempdir = Normalize(CrossProduct(DirectionTowards(horizontal_points[0],s), DirectionTowards(s,second))) ;
            //tempdir = Normalize(tempdir * DotProduct(tempdir,Up()));
            angle = AngleBetweenVectors(Down(),DirectionTowards(horizontal_points[0],seconds));
            Wait(0.016);
            }

            firstpos[CountOf(firstpos)] = horizontal_points[0];
            secondpos[CountOf(secondpos)] = second;
            firstpoint2[CountOf(firstpoint2)] = s; //hor[1]
            secondpoint2[CountOf(secondpoint2)] = second + DirectionTowards(horizontal_points[1], horizontal_points[0]) *DistanceBetween(horizontal_points[0],horizontal_points[1]);


            DestroyEffect(beams[0]);
            DestroyEffect(beams[1]);
            DestroyEffect(beams[2]);
            DestroyEffect(beams[3]);
            DestroyEffect(horizontal_effect_id[0]);
            DestroyEffect(horizontal_effect_id[1]);

            AllPos[CountOf(AllPos)] = (horizontal_points[0] + second)/2;

            AllDir[CountOf(AllDir)] = Normalize(CrossProduct(DirectionTowards(horizontal_points[0],firstpoint2[CountOf(firstpoint2)-1]), DirectionTowards(firstpoint2[CountOf(firstpoint2)-1],secondpos[CountOf(secondpos)-1]))) ;
            AllDir[CountOf(AllDir)-1] = Normalize( AllDir[CountOf(AllDir)-1] * DotProduct(AllDir[CountOf(AllDir)-1],Up()));

            Wall_ID[CountOf(Wall_ID)] = UI_ID;

            g_beamType[CountOf(g_beamType)] = beamType;


            //DirectionTowards(firstpos[0],secondpoint2[0]) * DotProduct(Down(),DirectionTowards(firstpos[0],secondpoint2[0]))
            switch(beamType)
            {
                case 1:
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

                 case 2:
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

                 case 3:
                CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                 CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                 break;

            }



            horizontal_points = EmptyArray();
            horizontal_effect_id = EmptyArray();

            for(define tempcount =0;4;1)
            {
                DestroyInWorldText(measureTextEntity[tempcount]);
            }

            measureTextEntity = EmptyArray();
            //Wait(0.5);

        }

}



//Sphere
rule: "Sphere"
Event.OngoingPlayer
if(IsButtonHeld(eventPlayer,Button.Interact) && UI_ID == 9)
{
        define center = point;
        define tempsphereradius = 0;
        define effectid;
        CreateEffect(AllPlayers(),Effect.Sphere,Color.White,center,tempsphereradius,EffectRev.PositionAndRadius);
        effectid[0] = LastCreatedEntity();
        CreateEffect(AllPlayers(),Effect.Sphere,Color.White,center,0.1,EffectRev.VisibleTo);
        effectid[1] = LastCreatedEntity();
        Wait(0.3);
         while(IsButtonHeld(eventPlayer,Button.Interact) == true)
         {
            tempsphereradius = DistanceBetween(center, point);
            Wait(0.016);
         }
        DestroyEffect(effectid[0]);
        DestroyEffect(effectid[1]);
        AllPos[CountOf(AllPos)] = center;
        sphereRadius[CountOf(AllPos)-1] = tempsphereradius;
        firstpos[CountOf(firstpos)] = 0;
        secondpos[CountOf(secondpos)] = 0;
        firstpoint2[CountOf(firstpoint2)] = 0; //hor[1]
        secondpoint2[CountOf(secondpoint2)] = 0;
        AllDir[CountOf(AllDir)] = 0;
        g_beamType[CountOf(g_beamType)] = 0;
        Wall_ID[CountOf(Wall_ID)] = UI_ID;
        CreateEffect(AllPlayers(),Effect.Sphere,Color.Orange,center,sphereRadius[CountOf(sphereRadius)-1],EffectRev.VisibleTo);
        beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
}


//Teleporter
rule: "Teleporter"
Event.OngoingPlayer
if(IsButtonHeld(eventPlayer,Button.Interact) && UI_ID == 10)
{

        teleport_temp_point[CountOf(teleport_temp_point)] = point;


         CreateEffect(AllPlayers(),Effect.GoodAura,CountOf(teleport_temp_point) == 1? Color.Green:Color.Red,EvaluateOnce(teleport_temp_point[CountOf(teleport_temp_point)-1]),1.5,EffectRev.VisibleTo);
         teleport_effect_ID[CountOf(teleport_effect_ID)] = LastCreatedEntity();
         CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,teleport_temp_point[CountOf(teleport_temp_point)-1],point);
         teleport_beameffect_ID = LastCreatedEntity();


    Wait(0.3);
    define tempDirection;
    while(!IsButtonHeld(eventPlayer,Button.Interact))
    {
        Wait(0.016);
        tempDirection = DirectionTowards(teleport_temp_point[CountOf(teleport_temp_point)-1],point);
    }
    teleportDirection[CountOf(teleportDirection)] = tempDirection;
    DestroyEffect(teleport_beameffect_ID);

        if(CountOf(teleport_temp_point)==2)
        {
                teleportPos[CountOf(teleportPos)] = teleport_temp_point[0];
                teleportPos[CountOf(teleportPos)] = teleport_temp_point[1];
                // CreateEffect(AllPlayers(),Effect.GoodAura,Color.Red,teleport_temp_point[CountOf(teleport_temp_point)-1],1.5,EffectRev.VisibleTo);
                // teleport_effect_ID[CountOf(teleport_effect_ID)] = LastCreatedEntity();

            teleport_temp_point = EmptyArray();

            //Wait(0.5);

        }

}

rule: "Teleport"
Event.OngoingPlayer
if(CountOf(teleportPos) > 0 && IsTrueForAny(teleportPos,DistanceBetween(eventPlayer,ArrayElement()) < 4))
{
    define closestTeleporter = FirstOf(SortedArray(teleportPos,DistanceBetween(eventPlayer,ArrayElement())));
    define teleporterIndex = IndexOfArrayValue(teleportPos,closestTeleporter);
    define prev_Tele_Speed = SpeedOf();
    if(teleporterIndex == 0 || Modulo(teleporterIndex,2) == 0) //even
    {
        teleporting = true;
        Wait(0.016);
        Teleport(eventPlayer,teleportPos[teleporterIndex + 1]);
        ApplyImpulse(eventPlayer, VelocityOf() * -1, 0.001,Relative.ToWorld,ContraryMotion.CancelXYZ);
        ApplyImpulse(eventPlayer, teleportDirection[teleporterIndex + 1], prev_Tele_Speed,Relative.ToWorld,ContraryMotion.CancelXYZ);
        SetFacing(eventPlayer,Vector(XOf(teleportDirection[teleporterIndex + 1]),YOf(FacingDirectionOf()),ZOf(teleportDirection[teleporterIndex + 1])));
        //CreateBeamEffect(eventPlayer,BeamType.GoodBeam,teleportPos[teleporterIndex + 1],teleportPos[teleporterIndex + 1] + teleportDirection[teleporterIndex + 1] * 5);
        teleporting = false;
        lastsavedpos = PositionOf();

    }
    else if(Modulo(teleporterIndex,2) == 1) //odd
    {
         teleporting = true;
        Wait(0.016);
        Teleport(eventPlayer,teleportPos[teleporterIndex - 1]);
        ApplyImpulse(eventPlayer, VelocityOf() * -1, 0.001,Relative.ToWorld,ContraryMotion.CancelXYZ);
        ApplyImpulse(eventPlayer, teleportDirection[teleporterIndex - 1], prev_Tele_Speed,Relative.ToWorld,ContraryMotion.CancelXYZ);
        SetFacing(eventPlayer,Vector(XOf(teleportDirection[teleporterIndex - 1]),YOf(FacingDirectionOf()),ZOf(teleportDirection[teleporterIndex - 1])));
        //CreateBeamEffect(eventPlayer,BeamType.GoodBeam,teleportPos[teleporterIndex - 1],teleportPos[teleporterIndex - 1] + teleportDirection[teleporterIndex - 1] * 5);
        teleporting = false;
        lastsavedpos = PositionOf();

    }
}

rule: "Fly Mode"
Event.OngoingPlayer
if(flymode)
{
    SetGravity(eventPlayer,0);
    DisableMovementCollisionWithEnvironment(eventPlayer,true);
    DisallowButton(eventPlayer,Button.Ability1);
    DisallowButton(eventPlayer,Button.Ability2);
    max_horizontal_speed = 5.5;
    define flyspeed;
    while(flymode)
    {
        // if(IsButtonHeld(eventPlayer,Button.Reload))
        // DisableMovementCollisionWithEnvironment(eventPlayer,true)
        // else
        // EnableMovementCollisionWithEnvironment();

        if(IsButtonHeld(eventPlayer,Button.Ability2)== true)
        flyspeed = 50;
        else if(IsButtonHeld(eventPlayer,Button.Ability1)== true)
        flyspeed = 3;
        else
        flyspeed = 10;

        if(ThrottleOf() != Vector(0,0,0))
        {
        // ApplyImpulse(eventPlayer, CrossProduct(Up(),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)))  , 0.001);
        // ApplyImpulse(eventPlayer, CrossProduct(Down(),Normalize(WorldVectorOf(ThrottleOf(),eventPlayer))) , 0.001);
        ApplyImpulse(eventPlayer, VelocityOf() * Vector(1,0,1) * -1 , 0.001);
        ApplyImpulse(eventPlayer, DirectionTowards(EyePosition(),EyePosition() + Normalize(WorldVectorOf(ThrottleOf(),eventPlayer)) * 1)  , flyspeed);
        if(IsButtonHeld(eventPlayer,Button.Crouch) == false)
        ApplyImpulse(eventPlayer, Up(), 0.001);
        if(IsButtonHeld(eventPlayer,Button.Jump) == false)
        ApplyImpulse(eventPlayer, Down(), 0.001);
        }
         else
        {
        //ApplyImpulse(eventPlayer, Up(), 0.001);

            if(SpeedOf()>0.01)
            {
                ApplyImpulse(eventPlayer, Left(), 0.001);
                ApplyImpulse(eventPlayer, Right(), 0.001);
                ApplyImpulse(eventPlayer, Forward(), 0.001);
                ApplyImpulse(eventPlayer, Backward(), 0.001);
                if(IsButtonHeld(eventPlayer,Button.Crouch)== false)
                ApplyImpulse(eventPlayer, Up(), 0.001);
                if(IsButtonHeld(eventPlayer,Button.Jump)== false)
                ApplyImpulse(eventPlayer, Down(), 0.001);

            }



        }

        if(IsButtonHeld(eventPlayer,Button.Jump))
        ApplyImpulse(eventPlayer, Up(), flyspeed);
        else if(IsButtonHeld(eventPlayer,Button.Crouch))
        ApplyImpulse(eventPlayer, Down(), flyspeed);
        Wait(0.016);
    }

    SetGravity(eventPlayer,100);
    if(strafeToggle)
    DisableMovementCollisionWithEnvironment();
    else
    EnableMovementCollisionWithEnvironment();
    AllowButton(eventPlayer,Button.Ability1);
    AllowButton(eventPlayer,Button.Ability2);
}


rule: "Effect Creation"
Event.OngoingGlobal
{
Wait(5);
if(showwalls)
{
    for(define x =0; CountOf(AllPos);1)
    {
        if(ArrayContains([1,3,5],Wall_ID[x]))
        {
            if(Wall_ID[x] == 5)
            {
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x], Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x]+Vector(0.001,0,0), Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            }
            else
            {
                switch(g_beamType[x])
                {
                case 1:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,firstpos[x], Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,firstpos[x]+Vector(0.001,0,0), Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

                case 2:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x], Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x]+Vector(0.001,0,0), Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

                case 3:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,firstpos[x], Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,Vector(XOf(secondpos[x]),YOf(firstpos[x]),ZOf(secondpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,firstpos[x]+Vector(0.001,0,0), Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,Vector(XOf(firstpos[x]),YOf(secondpos[x]),ZOf(firstpos[x])), secondpos[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

                }

            }
        }
        else if(ArrayContains([2,4,6,7,8],Wall_ID[x]))
        {
           if(Wall_ID[x] == 6)
            {
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x], firstpoint2[x] + Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpoint2[x]+ Vector(0,0,0.001), secondpos[x],Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,secondpos[x], secondpoint2[x]+ Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
            CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,secondpoint2[x]+ Vector(0,0,0.001), firstpos[x],Color.Red,EffectRev.VisibleTo);
            beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            }
            else
            {
            switch(g_beamType[x])
            {
                case 1:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,firstpos[x], firstpoint2[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,firstpoint2[x]+ Vector(0,0,0.001), secondpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,secondpos[x], secondpoint2[x]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GrappleBeam,secondpoint2[x]+ Vector(0,0,0.001), firstpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

                case 2:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpos[x], firstpoint2[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,firstpoint2[x]+ Vector(0,0,0.001), secondpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,secondpos[x], secondpoint2[x]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.GoodBeam,secondpoint2[x]+ Vector(0,0,0.001), firstpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

                case 3:
                //CreateEffect(AllPlayers(),Effect.Sphere,Color.Yellow, (firstpos[x]+secondpos[x])/2,0.1,EffectRev.VisibleTo);
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,firstpos[x], firstpoint2[x] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,firstpoint2[x]+ Vector(0,0,0.001), secondpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,secondpos[x], secondpoint2[x]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();
                CreateBeamEffect(AllPlayers(),BeamType.BadBeam,secondpoint2[x]+ Vector(0,0,0.001), firstpos[x],Color.Aqua,EffectRev.VisibleTo);
                 beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                break;

            }

            }
        }
        else if(Wall_ID[x] == 9)
        {
            CreateEffect(AllPlayers(),Effect.Sphere,Color.Orange,AllPos[x],sphereRadius[x],EffectRev.VisibleTo);
        }
        Wait(0.016);
    }

    for(define x = 0; CountOf(teleportPos);2)
    {
        CreateEffect(AllPlayers(),Effect.GoodAura,Color.Green,teleportPos[x],1.5,EffectRev.VisibleTo);
        teleport_effect_ID[CountOf(teleport_effect_ID)] = LastCreatedEntity();
        CreateEffect(AllPlayers(),Effect.GoodAura,Color.Red,teleportPos[x+1],1.5,EffectRev.VisibleTo);
        teleport_effect_ID[CountOf(teleport_effect_ID)] = LastCreatedEntity();
    }
}

}




rule: "Open UI"
Event.OngoingPlayer
if(IsButtonHeld(EventPlayer(),Button.Melee) && arcballMode == false)
{
    openui = !openui;
    if(openui == false)
    {
        UI_SelectWall =false;
        Selected_Wall_Click = 0;
        DestroyEffect(Selected_Wall_Effect_ID[0]);
        DestroyEffect(Selected_Wall_Effect_ID[1]);
        Selected_Wall_Effect_ID = EmptyArray();
        AllowButton(eventPlayer,Button.PrimaryFire);
        AllowButton(eventPlayer,Button.SecondaryFire);
        confirmcount = 0;
    }
    else
    {
        Wait(0.016);
        radius = 0.1;
        DisallowButton(eventPlayer,Button.PrimaryFire);
        DisallowButton(eventPlayer,Button.SecondaryFire);
    }

}


//Mirror logic
rule: "Mirror"
Event.OngoingPlayer
if(start_mirror)
{
    start_mirror = false;
    SmallMessage(eventPlayer,"Select a Wall as the plane to Mirror from");
     temp_Selected_Wall = Selected_Wall_Click;
    define index_Mirror = IndexOfArrayValue(AllPos,temp_Selected_Wall);
    while(openui && temp_Selected_Wall == Selected_Wall_Click)
    {
        Wait(0.016);
    }
    if(temp_Selected_Wall != Selected_Wall_Click)
    {

        define index_Mirror2 = IndexOfArrayValue(AllPos,Selected_Wall_Click);
        // define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(DirectionTowards(lastsavedpos,fullbodypos) , AllDir[z]);
        // prevpos_intersection = RayCastHitPosition(fullbodypos,fullbodypos + (DirectionTowards(lastsavedpos,fullbodypos)) * intersection_length);
       define all_tempCorners = [firstpos[index_Mirror],firstpoint2[index_Mirror],secondpos[index_Mirror],secondpoint2[index_Mirror]];
       define tempCounter;
       define intersection;
       for(tempCounter; 4; 1)
       {
           intersection = all_tempCorners[tempCounter] + AllDir[index_Mirror2] * DotProduct(AllPos[index_Mirror2] - all_tempCorners[tempCounter],AllDir[index_Mirror2]) / DotProduct(AllDir[index_Mirror2], AllDir[index_Mirror2]);
           all_tempCorners[tempCounter] = intersection + -1  * DirectionTowards(intersection,all_tempCorners[tempCounter]) * DistanceBetween(intersection,all_tempCorners[tempCounter]);
       }
        firstpos[CountOf(firstpos)] = all_tempCorners[0];
        firstpoint2[CountOf(firstpoint2)] = all_tempCorners[1];
        secondpos[CountOf(secondpos)] = all_tempCorners[2];
        secondpoint2[CountOf(secondpoint2)] = all_tempCorners[3];
        AllPos[CountOf(AllPos)] = (all_tempCorners[0] + all_tempCorners[2])/2;
         if(Wall_ID[index_Mirror] == 8)
         {
            AllDir[CountOf(AllDir)] = Normalize(CrossProduct(DirectionTowards(all_tempCorners[0],all_tempCorners[1]), DirectionTowards(all_tempCorners[1],all_tempCorners[2]))) ;
            AllDir[CountOf(AllDir)-1] = Normalize( AllDir[CountOf(AllDir)-1] * DotProduct(AllDir[CountOf(AllDir)-1],Up()));
         }
         else
        AllDir[CountOf(AllDir)] = CrossProduct(DirectionTowards(all_tempCorners[0],all_tempCorners[1]),DirectionTowards(all_tempCorners[1],all_tempCorners[2]));

        if(YOf(AllDir[CountOf(AllDir)-1]) > -1 && YOf(AllDir[CountOf(AllDir)-1]) < 1 && YOf(AllDir[CountOf(AllDir)-1]) != 0)
        {
            if(Wall_ID[index_Mirror] == 8)
            Wall_ID[CountOf(Wall_ID)] = 8;
            else
            Wall_ID[CountOf(Wall_ID)] = 4;
        }
        else
        Wall_ID[CountOf(Wall_ID)] = Wall_ID[index_Mirror];
        g_beamType[CountOf(g_beamType)] = beamType;

        if(Wall_ID[index_Mirror] == 5 || Wall_ID[index_Mirror] == 6)
            {
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[0], all_tempCorners[1] + Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[1]+ Vector(0,0,0.001), all_tempCorners[2],Color.Red,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[2], all_tempCorners[3]+ Vector(0,0,0.001),Color.Red,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[3]+ Vector(0,0,0.001), all_tempCorners[0],Color.Red,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            }
            else
            {
            switch(beamType)
                {
                    case 1:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,all_tempCorners[0], all_tempCorners[1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,all_tempCorners[1]+ Vector(0,0,0.001), all_tempCorners[2],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,all_tempCorners[2], all_tempCorners[3]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,all_tempCorners[3]+ Vector(0,0,0.001), all_tempCorners[0],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;

                    case 2:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[0], all_tempCorners[1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[1]+ Vector(0,0,0.001), all_tempCorners[2],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[2], all_tempCorners[3]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,all_tempCorners[3]+ Vector(0,0,0.001), all_tempCorners[0],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;

                    case 3:
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,all_tempCorners[0], all_tempCorners[1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,all_tempCorners[1]+ Vector(0,0,0.001), all_tempCorners[2],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,all_tempCorners[2], all_tempCorners[3]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

                    CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,all_tempCorners[3]+ Vector(0,0,0.001), all_tempCorners[0],Color.Aqua,EffectRev.VisibleTo);
                    beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
                    break;

                }
            }





            // firstpos[CountOf(firstpos)] = horizontal_points[0];
            // secondpos[CountOf(secondpos)] = second;
            // firstpoint2[CountOf(firstpoint2)] = s; //hor[1]
            // secondpoint2[CountOf(secondpoint2)] = second + DirectionTowards(horizontal_points[1], horizontal_points[0]) *DistanceBetween(horizontal_points[0],horizontal_points[1]);

            // AllPos[CountOf(AllPos)] = (horizontal_points[0] + second)/2;

            // AllDir[CountOf(AllDir)] = Normalize(CrossProduct(DirectionTowards(horizontal_points[0],firstpoint2[CountOf(firstpoint2)-1]), DirectionTowards(firstpoint2[CountOf(firstpoint2)-1],secondpos[CountOf(secondpos)-1]))) ;
            // AllDir[CountOf(AllDir)-1] = Normalize( AllDir[CountOf(AllDir)-1] * DotProduct(AllDir[CountOf(AllDir)-1],Up()));

            // Wall_ID[CountOf(Wall_ID)] = UI_ID;

            // g_beamType[CountOf(g_beamType)] = beamType;


            //DirectionTowards(firstpos[0],secondpoint2[0]) * DotProduct(Down(),DirectionTowards(firstpos[0],secondpoint2[0]))
            // switch(beamType)
            // {
            //     case 1:
            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GrappleBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            //      break;

            //      case 2:
            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.GoodBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            //      break;

            //      case 3:
            //     CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,horizontal_points[0], firstpoint2[CountOf(firstpoint2)-1] + Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)][0] = LastCreatedEntity();
            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,firstpoint2[CountOf(firstpoint2)-1]+ Vector(0,0,0.001), second,Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][1] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,second, secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001),Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][2] = LastCreatedEntity();

            //      CreateBeamEffect(FilteredArray(AllPlayers(),showwalls == true),BeamType.BadBeam,secondpoint2[CountOf(secondpoint2)-1]+ Vector(0,0,0.001), horizontal_points[0],Color.Aqua,EffectRev.VisibleTo);
            //      beam_ID[CountOf(beam_ID)-1][3] = LastCreatedEntity();
            //      break;

            // }
    }
}


//spawn initialize
rule: "Player Spawn Initialize"
Event.OngoingPlayer
{


    //CreateEffect(eventPlayer,Effect.Sphere,Color.Red, EyePosition() + FacingDirectionOf() * (DotProduct(AllPos[z] - EyePosition(),AllDir[z]) / DotProduct(AllDir[z], AllDir[z])),0.1);

 // define intersection_length = DotProduct(AllPos[z] - fullbodypos,AllDir[z]) / DotProduct(DirectionTowards(lastsavedpos,fullbodypos) , AllDir[z]);
     //prevpos_intersection = RayCastHitPosition(fullbodypos,fullbodypos + (DirectionTowards(lastsavedpos,fullbodypos)) * intersection_length);

    //CreateHudText(eventPlayer,ServerLoad());
    //CreateHudText(eventPlayer,AngleBetweenVectors(AllDir,DirectionTowards(AllPos,eventPlayer)));
    //  CreateHudText(eventPlayer,<"Current Pos <0>",PositionOf()>);
    //  CreateHudText(eventPlayer,<"Saved Pos <0>",test_saved_pos[0]>);
    //  CreateHudText(eventPlayer,<"fullbody <0>",test_saved_pos[1]>);
    //  CreateHudText(eventPlayer,<"perp <0>",test_saved_pos[2]>);
    //  CreateHudText(eventPlayer,<"cursor <0>",cursor_snap_Tool>);
    if(CountOf(AllPos) > 0)
    {
        WaitUntil(HasSpawned(),999);
        flymode = true;
        Teleport(eventPlayer,AllPos[0]);

    }


    CreateEffect(AllPlayers(),Effect.Sphere,Color.White, point,radius);
    //CreateEffect(AllPlayers(),Effect.Sphere,Color.Red, filterpos,0.1);

    ///////////////////////////////UI INWORLD TEXT/////////////////////////////
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Reset ALL-", UIVector[0]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);

    // CreateInWorldText(FilteredArray(eventPlayer,openui && showwalls == false && page==1),"-Show ALL Wall-", UIVector[1]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && showwalls && page==1),"-Hide ALL Wall-", UIVector[1]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);

    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==0 && page==1),"Current Wall: \n\n-No Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==1 && page==1),"Current Wall: \n\n-Vertical Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==2 && page==1),"Current Wall: \n\n-Horizontal Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==3 && page==1),"Current Wall: \n\n-Bouncy Vertical Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==4 && page==1),"Current Wall: \n\n-Sloped Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==5 && page==1),"Current Wall: \n\n-Vertical Wall Eraser-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==6 && page==1),"Current Wall: \n\n-Horizontal Wall Eraser-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==7 && page==1),"Current Wall: \n\n-Slidey Horizontal Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==8 && page==1),"Current Wall: \n\n-Angled Sloped Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==9 && page==1),"Current Wall: \n\n-Sphere-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // //CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==7 && page==1),"Current Wall: \n\n-Sphere-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui),"-Wall Collision Disabled When Menu is Opened-", UIVector[3]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Red);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Select a Wall-", UIVector[4] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Delete-", UIVector[5] + Vector(0,-0.3,0),0.7,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.White);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Mirror-", UIVector[13] + Vector(0,-0.3,0),0.7,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.White);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Select Hero-", UIVector[6] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && cursor_snap_Tool==0 && page==2),"Cursor Snap Tool:\n\n        -None-", UIVector[10] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && cursor_snap_Tool==1 && page==2),"Cursor Snap Tool:\n\n       -Corners-", UIVector[10] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && cursor_snap_Tool==2 && page==2),"Cursor Snap Tool:\n\n-Corners and Beams-", UIVector[10] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"Next Page ->", UIVector[8] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Turquoise);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),"<- Prev Page", UIVector[8] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Turquoise);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),"-Compile-", UIVector[9] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1 && flymode == true),"-Fly Mode: ON-", UIVector[7] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1 && flymode == false),"-Fly Mode: OFF-", UIVector[7] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && beamType == 1),"BeamType:\n\n Grapple Beam-", UIVector[11] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && beamType == 2),"BeamType:\n\n Good Beam-", UIVector[11] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && beamType == 3),"BeamType:\n\n Bad Beam-", UIVector[11] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && arcballMode == false),"-ArcBall Camera-", UIVector[12] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // ////////////////////////////////////////////////////////////////////////////

    // ////////////////////////////////////////////////////HUD//////////////////////////////////////////
    //  CreateHudText(eventPlayer,null,"Created By: Oddish#11826\n     Grandeur Hammers\nbit.ly/GHammersDiscord",null,Location.Right,0,Color.Aqua,Color.Orange,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,openui == false && arcballMode == false),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Melee to open menu",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,UI_ID != 0 && openui && page==1 && point == UIVector[2]),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select 2 Points first by Pressing F\n-Secondary Fire to go to prev selection",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,openui && page==1 && point == UIVector[7]),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Hold Shift To Slow tf Down\n-Collision is Disabled during FlyMode\n-Space = UP, Crouch = Down",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,openui && page==2 && point == UIVector[10] && cursor_snap_Tool == 1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-White sphere cursor will snap to Closest Corner to your aim",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,openui && page==2 && point == UIVector[10] && cursor_snap_Tool == 2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Cursor will snap to the Yellow Beam axis that extends across the map\n-Will be abit more server intensive",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[4]  && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select this option first to toggle. Select a wall, then click an option below.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[13] && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-After you selected a Wall, Click Mirror then Select another plane(Wall) to mirror from.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[6] && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-May bug out sometimes, just keep trying lol",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[9] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select when you're finish.\n-Open inspector, then change the target to GLOBAL\n-Click (x) to copy data",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[11] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Walls will be made with this beam type except for Eraser walls",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,point == UIVector[12] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Let me give you an Advice. This device is meant to be Precise.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
    //  CreateHudText(FilteredArray(eventPlayer,arcballMode==true),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Reload to CANCEL this Mode\n-Jump to go up\n-Crouch to go down",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     ///////////////////////////////////////////////////////////////////////////////////////////////

define wallstring = [
        "Current Wall: \n\n-No Wall-",
        "Current Wall: \n\n-Vertical Wall-",
        "Current Wall: \n\n-Horizontal Wall-",
        "Current Wall: \n\n-Bouncy Vertical Wall-",
        "Current Wall: \n\n-Sloped Wall-",
        "Current Wall: \n\n-Vertical Wall Eraser-",
        "Current Wall: \n\n-Horizontal Wall Eraser-",
        "Current Wall: \n\n-Slidey Horizontal Wall-",
        "Current Wall: \n\n-Angled Sloped Wall-",
        "Current Wall: \n\n-Sphere-",
        "Current Object: \n\n-Teleporter-"];
   // CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Reset ALL-", UpdateEveryFrame(RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15,VerticalAngleFromDirection(UI_FacingDir)-5) * 5)+ Vector(0,-0.3,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
     CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Reset ALL-", UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,-0.8,0.5)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);

    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),showwalls? "-Hide ALL Wall-" : "-Show ALL Wall-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0,0.5)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionStringAndColor,showwalls? Color.Green : Color.Orange);


    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),wallstring[UI_ID],UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0.8,0.5)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==1 && page==1),"Current Wall: \n\n-Vertical Wall-", UpdateEveryFrame(RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-15,VerticalAngleFromDirection(UI_FacingDir)-5) * 5)+ Vector(0,-0.3,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==2 && page==1),"Current Wall: \n\n-Horizontal Wall-", UpdateEveryFrame(RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-15,VerticalAngleFromDirection(UI_FacingDir)-5) * 5)+ Vector(0,-0.3,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==3 && page==1),"Current Wall: \n\n-Bouncy Vertical Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==4 && page==1),"Current Wall: \n\n-Sloped Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==5 && page==1),"Current Wall: \n\n-Vertical Wall Eraser-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==6 && page==1),"Current Wall: \n\n-Horizontal Wall Eraser-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==7 && page==1),"Current Wall: \n\n-Slidey Horizontal Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==8 && page==1),"Current Wall: \n\n-Angled Sloped Wall-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==9 && page==1),"Current Wall: \n\n-Sphere-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    //CreateInWorldText(FilteredArray(eventPlayer,openui && UI_ID==7 && page==1),"Current Wall: \n\n-Sphere-", UIVector[2]+ Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
   CreateInWorldText(FilteredArray(eventPlayer,openui),"-Map Editor Menu-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0,1)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Orange);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Select a Wall-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,-0.8,-0.1)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndColor,UI_SelectWall ? Color.Orange :  Color.Green);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1 && Selected_Wall_Click && UI_SelectWall),"-Delete-",UIVector[5]+ Vector(0,-0.4,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndColor,point == UIVector[5] ? Color.Orange : Color.White);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1 && Selected_Wall_Click && UI_SelectWall),"-Mirror-",UIVector[13]+ Vector(0,-0.4,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndColor,point == UIVector[13] ? Color.Orange : Color.White);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),"-Select Hero-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0,-0.1)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
        define cursorsnapString = [
        "Cursor Snap Tool:\n\n        -None-",
        "Cursor Snap Tool:\n\n       -Corners and Middle-",
        "Cursor Snap Tool:\n\n-Corners and Beams-"];
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),cursorsnapString[cursor_snap_Tool],UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0,0.5)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && cursor_snap_Tool==1 && page==2),"Cursor Snap Tool:\n\n       -Corners-", UIVector[10] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    // CreateInWorldText(FilteredArray(eventPlayer,openui && cursor_snap_Tool==2 && page==2),"Cursor Snap Tool:\n\n-Corners and Beams-", UIVector[10] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    CreateInWorldText(FilteredArray(eventPlayer,openui),page == 1? "Next Page ->" : "<- Prev Page",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,1.2,0.25)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Turquoise);
    //CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),"<- Prev Page", UIVector[8] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Turquoise);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),"-Compile-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,-0.8,0.5)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==1),flymode?"-Fly Mode: ON-" : "-Fly Mode: Off-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0.8,-0.1)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionStringAndColor,flymode?Color.Orange:Color.Green);
    //CreateInWorldText(FilteredArray(eventPlayer,openui && page==1 && flymode == false),"-Fly Mode: OFF-", UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0.8,-0.1)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
         define beamString = [
        "BeamType:\n\n -Grapple Beam-",
        "BeamType:\n\n -Good Beam-",
        "BeamType:\n\n -Bad Beam-"];
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==2),beamString[beamType-1],UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,0.8,-0.1001)+ Vector(0,0.5,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    //CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && beamType == 2),"BeamType:\n\n Good Beam-", UIVector[11] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    //CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && beamType == 3),"BeamType:\n\n Bad Beam-", UIVector[11] + Vector(0,-0.3,0),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    CreateInWorldText(FilteredArray(eventPlayer,openui && page==2 && arcballMode == false),"-ArcBall Camera-",UpdateEveryFrame(ScreenToWorldForPlayer(eventPlayer,-0.8,-0.1001)+ Vector(0,-0.4,0)),1,Clipping.DoNotClip,InworldTextRev.VisibleToPositionAndString,Color.Green);
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////HUD//////////////////////////////////////////
    CreateHudText(eventPlayer,ServerLoad(),null,null,Location.Left,0,Color.White,Color.Orange,Color.White);
    CreateHudText(eventPlayer,<"Position Of: <0>",PositionOf()>,null,null,Location.Left,0,Color.White,Color.Orange,Color.White);
    CreateHudText(eventPlayer,null,<"Walls Made: <0>",CountOf(AllPos)>,null,Location.Top,100,Color.Orange,Color.Orange,Color.Orange);
    CreateHudText(eventPlayer,null,<"Objects Made: <0>",CountOf(teleportPos)>,null,Location.Top,101,Color.Orange,Color.Orange,Color.Orange);

     CreateHudText(eventPlayer,null,"Created By: Yurodd\n     Grandeur Hammers\nbit.ly/GHammersDiscord",null,Location.Right,0,Color.Aqua,Color.Orange,Color.White);
     CreateHudText(FilteredArray(eventPlayer,openui == false && arcballMode == false),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Melee to open menu",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,UI_ID != 0 && openui && page==1 && point == UIVector[2]),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select 2 Points first by Pressing F\n-Secondary Fire to go to prev selection",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,openui && page==1 && point == UIVector[7]),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Hold Shift To Slow tf Down\n-Collision is Disabled during FlyMode\n-Space = UP, Crouch = Down",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,openui && page==2 && point == UIVector[10] && cursor_snap_Tool == 1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-White sphere cursor will snap to Closest Corner to your aim",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,openui && page==2 && point == UIVector[10] && cursor_snap_Tool == 2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Cursor will snap to the Yellow Beam axis that extends across the map\n-Will be abit more server intensive",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[4]  && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select this option first to toggle. Select a wall, then click an option below.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[13] && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-After you selected a Wall, Click Mirror then Select another plane(Wall) to mirror from.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[6] && openui && page==1),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-May bug out sometimes, just keep trying lol",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[9] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Select when you're finish.\n-Open inspector, then change the target to GLOBAL\n-Click (x) to copy data",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[11] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Walls will be made with this beam type except for Eraser walls",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,point == UIVector[12] && openui && page==2),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Let me give you an Advice. This device is meant to be Precise.",Location.Right,10,Color.Aqua,Color.Red,Color.White);
     CreateHudText(FilteredArray(eventPlayer,arcballMode==true),null,null," \n\n\n\n\n\n\n\n\n\n\n\n    ProTip:\n-Reload to CANCEL this Mode\n-Jump to go up\n-Crouch to go down",Location.Right,10,Color.Aqua,Color.Red,Color.White);



    lastsavedpos = EyePosition();

    WaitUntil(SpeedOf() > 1,5);
    if(strafeToggle)
    DisableMovementCollisionWithEnvironment();
   // ChaseVariableAtRate(lastsavedpos,fullbodypos,50,RateChaseReevaluation.DestinationAndRate);
}

define UpAxis(Vector zAxis): DirectionFromAngles(HorizontalAngleFromDirection(zAxis), VerticalAngleFromDirection(zAxis) - 90);

define RightAxis(Vector zAxis): CrossProduct(zAxis, UpAxis(zAxis));

define ScreenToWorldForPlayer(define player, define x, define y): ScreenToWorld(EyePosition(player), UI_FacingDir, x, y);
define ScreenToWorld(Vector position, Vector zAxis, define x, define y): RayCastHitPosition(position,<Vector>(position + 2 * (x * RightAxis(zAxis) + (y-0.2) * UpAxis(zAxis) + 3 * zAxis)));

rule: "IWT Pos"
Event.OngoingPlayer
if(openui)
{
   // DestroyAllInworldText();
    //DestroyAllHudText();
    //Wait(0.016);
    UI_FacingDir = FacingDirectionOf();


    while(openui)
    {
    //Reset
    UIVector[0] = ScreenToWorldForPlayer(eventPlayer,-0.8,0.5);
    //Hide Wall
    UIVector[1] = ScreenToWorldForPlayer(eventPlayer,0,0.5);
    //Horizonal wall
    UIVector[2] = ScreenToWorldForPlayer(eventPlayer,0.8,0.5);
    //Warning Text
    UIVector[3] = ScreenToWorldForPlayer(eventPlayer,0,1.1);
    //Select Wall
    UIVector[4] = ScreenToWorldForPlayer(eventPlayer,-0.8,-0.1);
    //Delete Wall
    //UIVector[5] = ScreenToWorldForPlayer(eventPlayer,-0.8,-0.3);
    UIVector[5] = null;
    //Switch Character
    UIVector[6] = ScreenToWorldForPlayer(eventPlayer,0,-0.1);
    //Flymode
    UIVector[7] = ScreenToWorldForPlayer(eventPlayer,0.8,-0.1);
    //Next Page
    UIVector[8] = ScreenToWorldForPlayer(eventPlayer,1.2,0.25);
    //Compile
    UIVector[9] = ScreenToWorldForPlayer(eventPlayer,-0.8,0.5001);
    //Cursor
    UIVector[10] = ScreenToWorldForPlayer(eventPlayer,0,0.5001);
    //beamType
    UIVector[11] = ScreenToWorldForPlayer(eventPlayer,0.8,0.5001);
    //arcball
    UIVector[12] = ScreenToWorldForPlayer(eventPlayer,-0.8,-0.1001);
    //Mirror
    //UIVector[13] = ScreenToWorldForPlayer(eventPlayer,-0.8,-0.4);
    UIVector[13] = null;
    //ResetAll
    //UIVector[0] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15,VerticalAngleFromDirection(UI_FacingDir)-5) * 5) ;
    //Show/Hide Wall
    // UIVector[1] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir),VerticalAngleFromDirection(UI_FacingDir)-5) * 5) ;
    // //Horizonal wall
    // UIVector[2] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-15,VerticalAngleFromDirection(UI_FacingDir)-5) * 5) ;
    // //Warning Text
    // UIVector[3] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir),VerticalAngleFromDirection(UI_FacingDir)-15) * 5) ;
    // //Select Wall
    // UIVector[4] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15,VerticalAngleFromDirection(UI_FacingDir)+5) * 5) ;
    // //Delete Wall
    // UIVector[5] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15,VerticalAngleFromDirection(UI_FacingDir)+7.5) * 5) ;
    // //Switch Character
    // UIVector[6] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir),VerticalAngleFromDirection(UI_FacingDir)+5) * 5) ;
    // //Cursor Snap
    // UIVector[7] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-15,VerticalAngleFromDirection(UI_FacingDir)+5) * 5) ;
    // //Next Page
    // UIVector[8] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-21,VerticalAngleFromDirection(UI_FacingDir)) * 5) ;
    // //Compile
    // UIVector[9] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15.001,VerticalAngleFromDirection(UI_FacingDir)-5) * 5) ;
    // //Flymode
    // UIVector[10] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir),VerticalAngleFromDirection(UI_FacingDir)-5.001) * 5) ;
    // //beamType
    // UIVector[11] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)-15.001,VerticalAngleFromDirection(UI_FacingDir)-5) * 5) ;
    // //arcball
    // UIVector[12] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15.001,VerticalAngleFromDirection(UI_FacingDir)+5) * 5) ;
    // //Mirror
    // UIVector[13] = RayCastHitPosition(EyePosition(),EyePosition() + DirectionFromAngles(HorizontalAngleFromDirection(UI_FacingDir)+15,VerticalAngleFromDirection(UI_FacingDir)+9.5) * 5) ;
    Wait(0.016);
    }



}

rule: "Menu logic"
Event.OngoingPlayer
if(openui && IsAlive())
{
    define page1index;
    define page2index;
    if(page == 1)
    {
        define slice =
        [
            UIVector[0],//Reset
            UIVector[1],//Hide Wall
            UIVector[2],//Horizonal wall
            UIVector[3],//Warning Text
            UIVector[4],//Select Wall
            //UIVector[5],//Delete Wall
            UIVector[6],//Switch Character
            UIVector[7],//Flymode
            UIVector[8]//Next Page
            //UIVector[13] //Mirror

        ];

       // define slice = ArraySlice(UIVector,0,9);
        //slice[CountOf(slice)] = UIVector[13];
        point = FirstOf(SortedArray(slice,DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
    }
    else if(page == 2)
    {
        point = FirstOf(SortedArray(ArraySlice(UIVector,8,5),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
    }
    // if(page==1)
    // point = FirstOf(SortedArray(FilteredArray(UIVector,CurrentArrayIndex()<=8),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
    // else if(page==2)
    // {
    // point = FirstOf(SortedArray(FilteredArray(UIVector,CurrentArrayIndex()>=8),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
    // }
    //point = FirstOf(SortedArray(UIVector,DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));

        if(UI_SelectWall && (CountOf(AllPos) > 0 || CountOf(teleportPos) > 0))
        {
            Selected_Wall =  FirstOf(SortedArray(Append(AllPos,teleportPos),DotProduct(FacingDirectionOf(),DirectionTowards(ArrayElement(),EyePosition()))));
             if(Selected_Wall_Click)
            {
              UIVector[5] =   Selected_Wall_Click + Vector(0,1,0);
              UIVector[13] =   Selected_Wall_Click + Vector(0,-1,0);
              closestSelection = [point,Selected_Wall,UIVector[5],UIVector[13]];
            }
            else
            closestSelection = [point,Selected_Wall];

            closestSelection = FirstOf(SortedArray(closestSelection,DistanceBetween(ArrayElement(),EyePosition()+FacingDirectionOf()*DistanceBetween(EyePosition(),ArrayElement()))));
            point = closestSelection;
        }
        else
        {
        closestSelection = point;
        UI_SelectWall = false;
        }

    if(IsButtonHeld(eventPlayer,Button.PrimaryFire) || IsButtonHeld(eventPlayer,Button.SecondaryFire))
    {
        if(ArrayContains(UIVector,closestSelection))
        {
            PlayEffect(AllPlayers(),PlayEffect.GoodExplosion,Color.Green,point,0.1);
            PlayEffect(AllPlayers(),PlayEffect.BuffImpactSound,Color.Green,point,100);

            switch(IndexOfArrayValue(UIVector,point))
            {
                case 0 :
                confirmcount++;
                    if(confirmcount == 3)
                    {
                    destroyall = true;
                    confirmcount = 0;
                    SmallMessage(eventPlayer,"Confirm 3 times: Reset Done");
                    }
                    else
                    {
                    SmallMessage(eventPlayer,<"Confirm 3 times: <0>",confirmcount>);
                    }
                    break;
                case 1 : showwalls = !showwalls; break;
                //case 2 : UI_wallDirection = !UI_wallDirection; break;
                case 2 :
                     if(IsButtonHeld(eventPlayer,Button.PrimaryFire))
                   UI_ID = Modulo(UI_ID+1,11);
                    else if(IsButtonHeld(eventPlayer,Button.SecondaryFire))
                    {
                    UI_ID = Modulo(11+UI_ID-1,11);
                    }
                     break;
                case 4 :
                    if(CountOf(AllPos)>0 || CountOf(teleportPos) > 0)
                    {
                        UI_SelectWall = !UI_SelectWall;
                        if(UI_SelectWall)
                        {
                        CreateEffect(FilteredArray(AllPlayers(),openui == true && showwalls && UI_SelectWall && Selected_Wall == point),Effect.Sphere,Color.Yellow, Selected_Wall,(0.12/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(Selected_Wall,EyePosition())));
                        Selected_Wall_Effect_ID[0] = LastCreatedEntity();
                        CreateEffect(FilteredArray(AllPlayers(),openui == true && showwalls && UI_SelectWall),Effect.Sphere,Color.Green, Selected_Wall_Click,RadiusToScreen);
                        Selected_Wall_Effect_ID[1] = LastCreatedEntity();
                        }
                        else
                        {
                        DestroyEffect(Selected_Wall_Effect_ID[0]);
                        DestroyEffect(Selected_Wall_Effect_ID[1]);
                        Selected_Wall_Effect_ID = EmptyArray();
                        }
                    }
                    else
                    {
                        SmallMessage(eventPlayer,"Create a Wall First");
                    }
                    break;

                case 5 :
                    if( UI_SelectWall&& Selected_Wall_Click!=0)
                    {
                        if(ArrayContains(AllPos,Selected_Wall_Click))
                        {
                        define ID = IndexOfArrayValue(AllPos,Selected_Wall_Click);

                         for(define tempeffectcounter =0; 4;1)
                        {
                            DestroyEffect(beam_ID[ID][tempeffectcounter]);
                        }
                        beam_ID = FilteredArray(beam_ID,CurrentArrayIndex() != ID);
                        AllPos = FilteredArray(AllPos,CurrentArrayIndex() != ID);
                        AllDir = FilteredArray(AllDir,CurrentArrayIndex() != ID);
                        firstpos = FilteredArray(firstpos,CurrentArrayIndex() != ID);
                        secondpos = FilteredArray(secondpos,CurrentArrayIndex() != ID);
                        firstpoint2 = FilteredArray(firstpoint2,CurrentArrayIndex() != ID);
                        secondpoint2 = FilteredArray(secondpoint2,CurrentArrayIndex() != ID);
                        Wall_ID = FilteredArray(Wall_ID,CurrentArrayIndex() != ID);
                        active_wall = FilteredArray(active_wall,CurrentArrayIndex() != ID);
                        g_beamType = FilteredArray(g_beamType,CurrentArrayIndex() != ID);
                        }
                        else
                        {

                        define ID = IndexOfArrayValue(teleportPos,Selected_Wall_Click);

                             if(ID == 0 || Modulo(ID,2) == 0) //even
                                {

                                     DestroyEffect(teleport_effect_ID[ID]);//bookmark
                                     DestroyEffect(teleport_effect_ID[ID+1]);
                                     teleportPos = FilteredArray(teleportPos,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID+1);
                                     teleportDirection = FilteredArray(teleportDirection,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID+1);
                                     teleport_effect_ID = FilteredArray(teleport_effect_ID,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID+1);

                                }
                                else if(Modulo(ID,2) == 1) //odd
                                {
                                     DestroyEffect(teleport_effect_ID[ID]);//bookmark
                                     DestroyEffect(teleport_effect_ID[ID-1]);
                                     teleportPos = FilteredArray(teleportPos,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID-1);
                                     teleportDirection = FilteredArray(teleportDirection,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID-1);
                                     teleport_effect_ID = FilteredArray(teleport_effect_ID,CurrentArrayIndex() != ID && CurrentArrayIndex() != ID-1);
                                }

                        }

                        /* AllPos[ID] = 0;
                        AllDir[ID] = 0;
                        firstpos[ID] = 0;
                        secondpos[ID] = 0;
                        firstpoint2[ID] = 0;
                        secondpoint2[ID] = 0;
                        Wall_ID[ID] = 100;
                        active_wall[ID] = 0;
                        g_beamType[ID] = 0;
                        for(define x =0; 4;1)
                        {
                            DestroyEffect(beam_ID[ID][x]);
                        }
                        beam_ID[ID] = 0;
                        AllPos = FilteredArray(AllPos,ArrayElement()!=0);
                        AllDir = FilteredArray(AllDir,ArrayElement()!=0);
                        firstpos = FilteredArray(firstpos,ArrayElement()!=0);
                        secondpos = FilteredArray(secondpos,ArrayElement()!=0);
                        firstpoint2 = FilteredArray(firstpoint2,ArrayElement()!=0);
                        secondpoint2 = FilteredArray(secondpoint2,ArrayElement()!=0);
                        Wall_ID = FilteredArray(Wall_ID,ArrayElement()!=100);
                        beam_ID = FilteredArray(beam_ID,ArrayElement()!=0);
                        active_wall = FilteredArray(active_wall,ArrayElement()!=0);
                        g_beamType = FilteredArray(g_beamType,ArrayElement()!=0); */
                        Selected_Wall_Click=0;

                        Wait(0.5);
                    }
                    else
                    {
                        SmallMessage(eventPlayer,"Please press 'Select a Wall' and have a Wall Selected first");
                        Wait(0.5);
                    }
                break;
                case 6 :
                     saved_pos = PositionOf();
                    SetAllowedHeroes(eventPlayer,RemoveFromArray(AllHeroes(),HeroOf()));
                    Wait(1);
                    SetAllowedHeroes(eventPlayer,AllHeroes());

                    while(HeroOf()==false)
                    {
                        Wait(0.016);
                    }
                    Teleport(eventPlayer,saved_pos);
                    break;
                case 7:  flymode = !flymode; break;
                case 8:
                    if(page==1)
                    page=2;
                    else if(page==2)
                    page=1;
                    break;
                case 9:
                define prev_beam_id;
                 define tempeffectid;
                 define tempbeamid;
                 define tempstrafetoggle;
                    if(HostPlayer() == eventPlayer)
                    {
                    EnableInspectorRecording();
                    SmallMessage(eventPlayer,"Compiled");
                    AllPos = AllPos;
                    AllDir = AllDir;
                    firstpos = firstpos;
                    secondpos = secondpos;
                    firstpoint2 = firstpoint2;
                    secondpoint2 = secondpoint2;
                    Wall_ID = Wall_ID;
                    active_wall = active_wall;
                    g_beamType = g_beamType;
                    prev_beam_id = beam_ID;
                    beam_ID = 0;
                    tempstrafetoggle =strafeToggle;
                    strafeToggle = null;

                    teleportPos = teleportPos;
                    teleportDirection = teleportDirection;
                    tempeffectid = teleport_effect_ID;
                    tempbeamid = teleport_beameffect_ID;
                    teleport_effect_ID = null;
                    teleport_beameffect_ID = null;

                    destroyall = null;

                    define x = 0;
                    second = 0;
                    //sphereRadius = sphereRadius;
                    DisableInspectorRecording();
                    }
                    else
                    SmallMessage(eventPlayer,"NO U Aint De Host");

                    strafeToggle = tempstrafetoggle;
                    beam_ID = prev_beam_id;
                    teleport_effect_ID = tempeffectid;
                    teleport_beameffect_ID = tempbeamid;
                    destroyall = false;
                    break;
                case 10:
                    if(IsButtonHeld(eventPlayer,Button.PrimaryFire))
                   cursor_snap_Tool = Modulo(cursor_snap_Tool+1,3);
                    else if(IsButtonHeld(eventPlayer,Button.SecondaryFire))
                    cursor_snap_Tool = Modulo(3+cursor_snap_Tool-1,3);

                    if(cursor_snap_Tool ==2)
                    {
                    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam ,point + beam_dir[IndexOfArrayValue(all_beam_intersection,point)] * 1000,point + -beam_dir[IndexOfArrayValue(all_beam_intersection,point)] * 1000,Color.Yellow);
                    beam_Cursor_ID = LastCreatedEntity();
                    }
                    else
                    DestroyEffect(beam_Cursor_ID);
                     break;
                case 11:
                    if(IsButtonHeld(eventPlayer,Button.PrimaryFire))
                    beamType++;
                    else if(IsButtonHeld(eventPlayer,Button.SecondaryFire))
                    beamType--;
                    break;

                case 12: arcballMode = !arcballMode; break;

                case 13:
                    if(UI_SelectWall&& Selected_Wall_Click!=0)
                    {
                    start_mirror = true;
                    Wait(0.2);
                    }
                    else
                    {
                        SmallMessage(eventPlayer,"Please press 'Select a Wall' and have a Wall Selected first");
                        Wait(0.2);
                    }
                break;


            }

                if(beamType > 3)
                beamType =1;
                else if(beamType < 1)
                beamType = 3;

             Wait(0.3);
        }

        else if(ArrayContains(Append(AllPos,teleportPos),closestSelection))
        {
            Selected_Wall_Click = Selected_Wall;
            PlayEffect(AllPlayers(),PlayEffect.GoodExplosion,Color.Green,Selected_Wall_Click,0.1);
            PlayEffect(AllPlayers(),PlayEffect.BuffImpactSound,Color.Green,point,100);
            PlayEffect(AllPlayers(),PlayEffect.BuffImpactSound,Color.Green,eventPlayer,100);
            Wait(0.3);
        }
    }

    MinWait();
    LoopIfConditionIsTrue();
}

rule: "Global Resets"
Event.OngoingGlobal
if(destroyall)
{
  AllPos = EmptyArray();
  AllDir = EmptyArray();
  firstpos = EmptyArray();
  secondpos = EmptyArray();
  firstpoint2 = EmptyArray();
  secondpoint2 = EmptyArray();
  Wall_ID = EmptyArray();
  g_beamType = EmptyArray();
  sphereRadius = EmptyArray();
  teleportPos = EmptyArray();
  teleport_effect_ID = EmptyArray();
  teleportDirection = EmptyArray();
  second=0;
  z=0;
  destroyall = false;
  DestroyAllEffects();
}
rule: "Player Resets"
Event.OngoingPlayer
if(destroyall)
{
  filterpos = EmptyArray();
  closestbodypos= EmptyArray();
  fullbodypos= EmptyArray();
  Selected_Wall_Effect_ID = EmptyArray();
  closestSelection = EmptyArray();
  active_wall = EmptyArray();
    point=0;
    beam_ID = EmptyArray();
    Wait(0.5);
    // CreateBeamEffect(FilteredArray(eventPlayer,UI_ID==0||UI_ID==2||UI_ID==5&&IsButtonHeld(ArrayElement(),Button.Interact)),BeamType.GrappleBeam,firstpos[CountOf(firstpos)-1], Vector(XOf(second),YOf(firstpos[CountOf(firstpos)-1]),ZOf(second)));
    // CreateBeamEffect(FilteredArray(eventPlayer,UI_ID==0||UI_ID==2||UI_ID==5&&IsButtonHeld(ArrayElement(),Button.Interact)),BeamType.GrappleBeam,Vector(XOf(second),YOf(firstpos[CountOf(firstpos)-1])+ Vector(0,0,0.001),ZOf(second)), second + Vector(0,0,0.001));
    // CreateBeamEffect(FilteredArray(eventPlayer,UI_ID==0||UI_ID==2||UI_ID==5&&IsButtonHeld(ArrayElement(),Button.Interact)),BeamType.GrappleBeam,firstpos[CountOf(firstpos)-1]+Vector(0.001,0,0), Vector(XOf(firstpos[CountOf(firstpos)-1]),YOf(second),ZOf(firstpos[CountOf(firstpos)-1])));
    // CreateBeamEffect(FilteredArray(eventPlayer,UI_ID==0||UI_ID==2||UI_ID==5&&IsButtonHeld(ArrayElement(),Button.Interact)),BeamType.GrappleBeam,Vector(XOf(firstpos[CountOf(firstpos)-1]+ Vector(0,0,0.001)),YOf(second),ZOf(firstpos[CountOf(firstpos)-1])), second + Vector(0,0,0.001));

    // CreateBeamEffect(FilteredArray(eventPlayer,IsButtonHeld(ArrayElement(),Button.Interact)&&UI_ID==1),BeamType.GrappleBeam,firstpos[CountOf(firstpos)-1], Vector(XOf(second),YOf(firstpos[CountOf(firstpos)-1]),ZOf(firstpos[CountOf(firstpos)-1])));
    // CreateBeamEffect(FilteredArray(eventPlayer,IsButtonHeld(ArrayElement(),Button.Interact)&&UI_ID==1),BeamType.GrappleBeam,Vector(XOf(second),YOf(firstpos[CountOf(firstpos)-1]),ZOf(firstpos[CountOf(firstpos)-1])), second);
    // CreateBeamEffect(FilteredArray(eventPlayer,IsButtonHeld(ArrayElement(),Button.Interact)&&UI_ID==1),BeamType.GrappleBeam,firstpos[CountOf(firstpos)-1], Vector(XOf(firstpos[CountOf(firstpos)-1]),YOf(firstpos[CountOf(firstpos)-1]),ZOf(second)));
    // CreateBeamEffect(FilteredArray(eventPlayer,IsButtonHeld(ArrayElement(),Button.Interact)&&UI_ID==1),BeamType.GrappleBeam,Vector(XOf(firstpos[CountOf(firstpos)-1]),YOf(firstpos[CountOf(firstpos)-1]),ZOf(second)), second);
    CreateEffect(AllPlayers(),Effect.Sphere,Color.White, point,radius);
    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam ,point + beam_dir[IndexOfArrayValue(all_beam_intersection,point)] * 1000,point + -beam_dir[IndexOfArrayValue(all_beam_intersection,point)] * 1000,Color.Yellow);
    beam_Cursor_ID = LastCreatedEntity();
    Wait(0.1);
}

////////////////Marcros//////////////////////////////////////
define eventPlayer: EventPlayer();
define RadiusToScreen : (0.12/4) * ((2*TangentFromRadians(0.7853975/2)) * DistanceBetween(Selected_Wall_Click,EyePosition()));
define ftbl: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(firstpos[z]),YOf(secondpos[z]),ZOf(firstpos[z]))),DirectionTowards(firstpos[z],filterpos));
define fttr: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(firstpos[z],filterpos));
define stbl: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(firstpos[z]),YOf(secondpos[z]),ZOf(firstpos[z]))),DirectionTowards(secondpos[z],filterpos));
define sttr: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(secondpos[z],filterpos));


//define ftbl2: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(firstpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(firstpos[z],filterpos));
//define fttr2: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(firstpos[z]))),DirectionTowards(firstpos[z],filterpos));
//define stbl2: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(firstpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(secondpos[z],filterpos));
//define sttr2: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(firstpos[z]))),DirectionTowards(secondpos[z],filterpos));

define ftbl2: DotProduct(DirectionTowards(firstpos[z],firstpoint2[z]),DirectionTowards(firstpos[z],filterpos));
define fttr2: DotProduct(DirectionTowards(firstpos[z],secondpoint2[z]),DirectionTowards(firstpos[z],filterpos));
define stbl2: DotProduct(DirectionTowards(secondpos[z],firstpoint2[z]),DirectionTowards(secondpos[z],filterpos));
define sttr2: DotProduct(DirectionTowards(secondpos[z],secondpoint2[z]),DirectionTowards(secondpos[z],filterpos));
///////////////////////////////////////////////////////////////
define ftbl2_prev_pos: DotProduct(DirectionTowards(firstpos[z],firstpoint2[z]),DirectionTowards(firstpos[z],prevpos_intersection));
define fttr2_prev_pos: DotProduct(DirectionTowards(firstpos[z],secondpoint2[z]),DirectionTowards(firstpos[z],prevpos_intersection));
define stbl2_prev_pos: DotProduct(DirectionTowards(secondpos[z],firstpoint2[z]),DirectionTowards(secondpos[z],prevpos_intersection));
define sttr2_prev_pos: DotProduct(DirectionTowards(secondpos[z],secondpoint2[z]),DirectionTowards(secondpos[z],prevpos_intersection));
//////////////////////////////////////////////////////////////
define ftbl_prev_pos: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(firstpos[z]),YOf(secondpos[z]),ZOf(firstpos[z]))),DirectionTowards(firstpos[z],prevpos_intersection));
define fttr_prev_pos: DotProduct(DirectionTowards(firstpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(firstpos[z],prevpos_intersection));
define stbl_prev_pos: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(firstpos[z]),YOf(secondpos[z]),ZOf(firstpos[z]))),DirectionTowards(secondpos[z],prevpos_intersection));
define sttr_prev_pos: DotProduct(DirectionTowards(secondpos[z],Vector(XOf(secondpos[z]),YOf(firstpos[z]),ZOf(secondpos[z]))),DirectionTowards(secondpos[z],prevpos_intersection));
/////////////////////////////////////////////////////////////
